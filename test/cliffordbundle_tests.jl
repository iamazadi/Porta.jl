# v ‚àà S¬≥
v = normalize(‚Ñç(rand(4)))
# constants c‚ÇÅ, c‚ÇÇ, c‚ÇÉ ‚àà ‚Ñù
c‚ÇÅ, c‚ÇÇ, c‚ÇÉ = rand(3)
# a ‚àà T·µ•S¬≥ in terms of the basis {K‚ÇÅv, K‚ÇÇv, K‚ÇÉv} for T·µ•S¬≥
a = c‚ÇÅ * (K(1) * v) + c‚ÇÇ * (K(2)* v) + c‚ÇÉ * (K(3) * v)

zerovector = ‚Ñù¬≥(0.0, 0.0, 0.0)

# Check if some vector in the horizontal subspace is not in the kernel of the pushforward by œÄ
@test !isapprox(zerovector, œÄ‚ú≥(Dualquaternion(v, K(1) * v)))
@test !isapprox(zerovector, œÄ‚ú≥(Dualquaternion(v, K(2) * v)))
# Check if some vector in the vertical subspace is in the kernel of the pushforward by œÄ
@test isapprox(zerovector, œÄ‚ú≥(Dualquaternion(v, K(3) * v)))
@test isapprox(œÄ‚ú≥(Dualquaternion(v, c‚ÇÅ * (K(1) * v) + c‚ÇÇ * (K(2)* v))), œÄ‚ú≥(Dualquaternion(v, a)))

Œ∏ = rand() * 2œÄ
# verify that using different coordinates yields the same result
@test isapprox(Œ¶(Œ∏, v), Œ¶(Œ∏, ‚Ñù‚Å¥(vec(v))))
@test isapprox(G(Œ∏, v), G(Œ∏, ‚Ñù‚Å¥(vec(v))))
@test isapprox(G(Œ∏, v), Œ¶(Œ∏, v))
@test isapprox(hopfmap(v), hopfmap(‚Ñù‚Å¥(vec(v))))


Œ± = rand()
# Check if some vector in the vertical subspace is in the kernel of the pushforward by œÄ
@test isapprox(zerovector, œÄ‚ú≥(Dualquaternion(v, ver(v, Œ±))), atol = TOLERANCE)

a, b, c, d = vec(v)
z‚ÇÅ = a + im * c
z‚ÇÇ = b + im * d
z = [z‚ÇÅ; z‚ÇÇ]
œµ = 1e-8
_tolerance = 1e-4
# v = (x‚ÇÅ, x‚ÇÇ, y‚ÇÅ, y‚ÇÇ)
# z = (z‚ÇÅ, z‚ÇÇ) = (x‚ÇÅ, x‚ÇÇ) + ùëñ (y‚ÇÅ, y‚ÇÇ)
# [d/dŒ∏(‚ÑØ‚Å±·∂øz)]_(Œ∏=0) = i‚ÑØ‚Å±·∂øz|_(Œ∏=0) = ùëñz
# Check if some tangent vector to the curve of points generated by the action, at the identity of the action, is ùëñz
@test isapprox(‚Ñç(im .* z), (Œ¶(œµ, v) - Œ¶(0, v)) * (1 / œµ), atol = _tolerance)
# Check if some tangent vector to the curve of points generated by the action, at the identity of the action, is in the vertical space
@test isapprox(zerovector, œÄ‚ú≥(Dualquaternion(v, (Œ¶(œµ, v) - Œ¶(0, v)) * (1 / œµ))), atol = 10TOLERANCE)

# [d/dŒ∏(G_Œ∏(v))]_(Œ∏=0) = [d/dŒ∏(G_Œ∏)]_(Œ∏=0)(v) = (-y‚ÇÅ, -y‚ÇÇ, x‚ÇÅ, x‚ÇÇ)
# Check if some tangent vector to the curve of points generated by the action, at the identity of the action, is (-y‚ÇÅ, -y‚ÇÇ, x‚ÇÅ, x‚ÇÇ)
@test isapprox(‚Ñç(-vec(v)[3], -vec(v)[4], vec(v)[1], vec(v)[2]), (G(œµ, v) - G(0, v)) * (1 / œµ), atol = TOLERANCE)
# Check if some tangent vector to the curve of points generated by the action, at the identity of the action, is in the vertical space
@test isapprox(zerovector, œÄ‚ú≥(Dualquaternion(v, (G(œµ, v) - G(0, v)) * (1 / œµ))), atol = 10TOLERANCE)

## Sections of the Hpf bundle

p = normalize(‚Ñù¬≥(rand(3)))
q = œÉmap(p)
g = œÑmap(p)

@test isapprox(norm(q), 1)
@test isapprox(norm(g), 1)

## The Hopf map

q = normalize(‚Ñç(rand(4)))
p = œÄmap(q)

@test isapprox(norm(p), 1)


## Connection 1-forms
œï = rand()
Œ∏ = rand()
q = ‚Ñç(exp(œï * K(1) + Œ∏ * K(2)))
œµ = 1e-5
u, v, a = calculateconnection(q, œµ = œµ)

@test typeof(u) <: ‚Ñù‚Å¥
@test typeof(v) <: ‚Ñù‚Å¥
@test typeof(a) <: Complex
@test isapprox(real(a), 0.0)

œï = rand() * 2œÄ
Œ∏ = rand() * 2œÄ
Œ± = rand() * 2œÄ
Œ≥ = rand() * 2œÄ
point =  ‚Ñç(exp(œï * K(1) + Œ∏ * K(2)) * exp(Œ± * K(3)))
X = ‚Ñç(exp((œï + œµ * sin(Œ≥)) * K(1) + (Œ∏ + œµ * cos(Œ≥)) * K(2)) * exp(Œ± * K(3))) - point
X = normalize(‚Ñù‚Å¥(vec(X)))
v, a = calculateconnection(point, X, œµ = œµ)
@test typeof(v) <: ‚Ñù‚Å¥
@test typeof(a) <: Complex
@test isapprox(real(a), 0.0)