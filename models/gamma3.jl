import FileIO
import DataFrames
import CSV
import GLMakie
using LinearAlgebra
using ModelingToolkit, DifferentialEquations, Latexify
using Porta


resolution = (1920, 1080)
segments = 180
frames_number = 360

r‚ÇÅ = 0.8 # experiments: 1-6
Œª‚ÇÅ = 1 + 0.2 * im # experiment 1
Œª‚ÇÇ = im # experiment 2
Œª‚ÇÉ = 2 + im # experiment 3
Œª‚ÇÑ = 0 # experiment 4
Œª‚ÇÖ = 1 # experiment 5
Œª‚ÇÜ = -im # experiment 6

r‚Çá = 0.5 # experiment 7
Œª‚Çá = -im # experiment 7

r‚Çà = 0.8 # experiment 8
Œª‚Çà = 2 - im # experiment 8

r‚ÇÄ = 0.8 # radius of lambda path circle
Œª‚ÇÄ = 1.0 + 0.2 * im # center of lambda path circle
œï‚ÇÄ = 0.0

operator = imag(Œª‚ÇÄ) ‚â• 0 ? "+" : "-"
version = "r‚ÇÄ=$(r‚ÇÄ)_Œª‚ÇÄ=$(float(real(Œª‚ÇÄ)))_$(operator)_ùëñ$(abs(float(imag(Œª‚ÇÄ))))"
modelname = "gamma3_$version"
L = 10.0 # max x range
L‚Ä≤ = -L
zÃÇ = [0.0; 0.0; 1.0]
Œ± = 0.05
markersize = 0.04
linewidth = 8.0
arrowsize = GLMakie.Vec3f(0.02, 0.02, 0.04)

getŒª(s) = Œª‚ÇÄ + r‚ÇÄ * exp(im * (s + œï‚ÇÄ))
getŒª‚Çõ(s, _r) = im * _r * exp(im * (s + œï‚ÇÄ))
getŒº(s) = ‚àö(getŒª(s) + 1)
getf(x) = (3 / 2) * sech(x / 2)^2
getA(x, s) = [0 1; getŒª(s) + 1 - 2getf(x) 0]
sqrt·µ£(r::Real, i::Real) = real(‚àö(r + im * i))
sqrt·µ¢(r::Real, i::Real) = imag(‚àö(r + im * i))
sqrt·µ£(r::Num, i::Num) = real(‚àö(r + im * i))
sqrt·µ¢(r::Num, i::Num) = imag(‚àö(r + im * i))
@register_symbolic sqrt·µ£(r, i)
@register_symbolic sqrt·µ¢(r, i)


"""
    getŒ≥‚ÇÅ(L, L‚Ä≤)

Get path Œ≥‚ÇÅ by integating a connection 1-form around a loop in Œª-space with the given interval [`L`,`L‚Ä≤`].
Rupert Way (2008)
"""
function getŒ≥‚ÇÅ(L::Float64, L‚Ä≤::Float64)
    s‚ÇÄ = L
    u‚ÇÄ = Quaternion([1.0; -‚àö(getŒª(s‚ÇÄ) + 1)])
    u‚Çó‚ÇÄ = Quaternion([0.0; -1 / 2(‚àö(getŒª(s‚ÇÄ) + 1))])
    v‚ÇÄ = normalize(u‚ÇÄ)
    w‚ÇÄ = œÄmap(v‚ÇÄ)
    Œª‚Çõ‚ÇÄ = getŒª‚Çõ(s‚ÇÄ, r‚ÇÄ)
    Œ∏‚ÇÄ = 0.0
    m‚ÇÄ = norm(u‚ÇÄ)
    # TDOO: define Œª‚Çõ in terms of the D differential operator
    # Define our state variables: state(t) = initial condition
    @variables t
    @variables Œª·µ£(t)=real(getŒª(L))
    @variables Œª·µ¢(t)=imag(getŒª(L))
    @variables Œª‚Çõ·µ£(t)=real(Œª‚Çõ‚ÇÄ)
    @variables Œª‚Çõ·µ¢(t)=imag(Œª‚Çõ‚ÇÄ)
    @variables u(t)[1:4]=vec(u‚ÇÄ)
    @variables u‚Çó(t)[1:4]=vec(u‚Çó‚ÇÄ)
    @variables v(t)[1:4]=vec(v‚ÇÄ)
    @variables w(t)[1:3]=w‚ÇÄ
    @variables Œ∏(t)=Œ∏‚ÇÄ
    @variables m(t)=m‚ÇÄ
    # Define our parameters
    @parameters r::Float64=r‚ÇÄ œï::Float64=œï‚ÇÄ
    # Define our differential: takes the derivative with respect to `t`
    D = Differential(t)
    # Define the differential equations
    eqs = [Œª·µ£ ~ real(getŒª(t))
           Œª·µ¢ ~ imag(getŒª(t))
           Œª‚Çõ·µ£ ~ real(getŒª‚Çõ(t, r))
           Œª‚Çõ·µ¢ ~ imag(getŒª‚Çõ(t, r))
           u[1] ~ 1.0
           u[2] ~ -sqrt·µ£(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))
           u[3] ~ 0.0
           u[4] ~ -sqrt·µ¢(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))
           u‚Çó[1] ~ 0.0
           u‚Çó[2] ~ real(-1 / 2(sqrt·µ£(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1)) + im * sqrt·µ¢(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))))
           u‚Çó[3] ~ 0.0
           u‚Çó[4] ~ imag(-1 / 2(sqrt·µ£(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1)) + im * sqrt·µ¢(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))))
           m ~ sqrt·µ£(sum(abs.([u[1] + u[3] * im; u[2] + u[4] * im]).^2), 0.0)
           v ~ u ./ m
           w[3] ~ real(conj(v[1] + v[3] * im) * (v[2] + v[4] * im) + (v[1] + v[3] * im) * conj(v[2]) + v[4] * im)
           w[2] ~ real(im * (conj(v[1] + v[3] * im) * (v[2] + v[4] * im) - (v[1] + v[3] * im) * conj(v[2] + v[4] * im)))
           w[1] ~ real(abs(v[1] + v[3] * im)^2 - abs(v[2] + v[4] * im)^2)
           D(Œ∏) ~ imag(u' * u‚Çó * (Œª‚Çõ·µ£ + Œª‚Çõ·µ¢ * im)) / (u' * u)]
    latex = latexify(eqs)
    # Bring these pieces together into an ODESystem with independent variable t
    @named sys = ODESystem(eqs, t)
    # Symbolically Simplify the System
    simpsys = structural_simplify(sys)
    # Convert from a symbolic to a numerical problem to simulate
    tspan = (L, L‚Ä≤)
    prob = ODEProblem(simpsys, [], tspan)
    # Solve the ODE
    sol = solve(prob)
    samples = length(sol[v])
    Œ≥‚ÇÅ = Vector{Quaternion}(undef, samples)
    phases = Vector{Float64}(undef, samples)
    path_Œª = Vector{Vector{Float64}}(undef, samples)
    s = Vector{Float64}(undef, samples)
    path_s2 = Vector{Vector{Float64}}(undef, samples)
    for i in 1:samples
        Œ≥‚ÇÅ[i] = Quaternion(sol[v][i])
        path_Œª[i] = convert_to_cartesian(sol[Œª·µ£][i] + im * sol[Œª·µ¢][i])
        phases[i] = sol[Œ∏][i]
        s[i] = sol[t][i]
        path_s2[i] = sol[w][i]
    end
    Œ≥‚ÇÅ, phases, path_Œª, path_s2, s, latex
end


"""
    getŒ≥‚ÇÇ(L, L‚Ä≤, s‚ÇÄ)

Get path Œ≥‚ÇÇ by integating a connection 1-form in the x direction with the given bounds [`L`,`L‚Ä≤`] and a fixed value for Œª `s‚ÇÄ`.
Rupert Way (2008)
"""
function getŒ≥‚ÇÇ(L::Float64, L‚Ä≤::Float64, s‚ÇÄ::Float64)
    Œº‚ÇÄ = getŒº(s‚ÇÄ)
    u‚ÇÄ = Quaternion([1.0; -Œº‚ÇÄ])
    Œ∏‚ÇÄ = 0.0
    v‚ÇÄ = normalize(u‚ÇÄ)
    w‚ÇÄ = œÄmap(v‚ÇÄ)
    m‚ÇÄ = norm(u‚ÇÄ)
    f‚ÇÄ = getf(s‚ÇÄ)
    Œª·µ£‚ÇÄ = real(getŒª(s‚ÇÄ))
    Œª·µ¢‚ÇÄ = imag(getŒª(s‚ÇÄ))
    # Define our state variables: state(t) = initial condition
    @variables t
    @variables f(t)=f‚ÇÄ
    @variables Œº·µ£(t)=real(Œº‚ÇÄ)
    @variables Œº·µ¢(t)=imag(Œº‚ÇÄ)
    @variables u(t)[1:4]=vec(u‚ÇÄ)
    @variables v(t)[1:4]=vec(v‚ÇÄ)
    @variables w(t)[1:3]=w‚ÇÄ
    @variables Œ∏(t)=Œ∏‚ÇÄ
    @variables m(t)=m‚ÇÄ
    # Define our parameters
    @parameters Œª·µ£::Float64=Œª·µ£‚ÇÄ Œª·µ¢::Float64=Œª·µ¢‚ÇÄ
    # Define our differential: takes the derivative with respect to `t`
    D = Differential(t)
    # Define the differential equations
    eqs = [Œº·µ£ ~ sqrt·µ£(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))
           Œº·µ¢ ~ sqrt·µ¢(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))
           f ~ getf(t)
           D(u[1]) ~ real( ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] + [Œº·µ£ + Œº·µ¢ * im 0; 0 Œº·µ£ + Œº·µ¢ * im]) * [u[1] + u[3] * im; u[2] + u[4] * im] )[1]
           D(u[2]) ~ real( ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] + [Œº·µ£ + Œº·µ¢ * im 0; 0 Œº·µ£ + Œº·µ¢ * im]) * [u[1] + u[3] * im; u[2] + u[4] * im] )[2]
           D(u[3]) ~ imag( ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] + [Œº·µ£ + Œº·µ¢ * im 0; 0 Œº·µ£ + Œº·µ¢ * im]) * [u[1] + u[3] * im; u[2] + u[4] * im] )[1]
           D(u[4]) ~ imag( ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] + [Œº·µ£ + Œº·µ¢ * im 0; 0 Œº·µ£ + Œº·µ¢ * im]) * [u[1] + u[3] * im; u[2] + u[4] * im] )[2]
           D(Œ∏) ~ imag(([u[1] + u[3] * im u[2] + u[4] * im] * ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] * [u[1] + u[3] * im; u[2] + u[4] * im]))[1]) / (u' * u)
           m ~ sqrt·µ£(sum(abs.([u[1] + u[3] * im; u[2] + u[4] * im]).^2), 0)
           v ~ u ./ m
           w[3] ~ real(conj(v[1] + v[3] * im) * (v[2] + v[4] * im) + (v[1] + v[3] * im) * conj(v[2]) + v[4] * im)
           w[2] ~ real(im * (conj(v[1] + v[3] * im) * (v[2] + v[4] * im) - (v[1] + v[3] * im) * conj(v[2] + v[4] * im)))
           w[1] ~ real(abs(v[1] + v[3] * im)^2 - abs(v[2] + v[4] * im)^2)]
    latex = latexify(eqs)
    # Bring these pieces together into an ODESystem with independent variable t
    @named sys = ODESystem(eqs, t)
    # Symbolically Simplify the System
    simpsys = structural_simplify(sys)
    # Convert from a symbolic to a numerical problem to simulate
    tspan = (L, L‚Ä≤)
    prob = ODEProblem(simpsys, [], tspan)
    # Solve the ODE
    sol = solve(prob)
    samples = length(sol[v])
    Œ≥‚ÇÇ = Vector{Quaternion}(undef, samples)
    u‚ÇÇ = Vector{Quaternion}(undef, samples)
    phases = Vector{Float64}(undef, samples)
    s = Vector{Float64}(undef, samples)
    path_s2 = Vector{Vector{Float64}}(undef, samples)
    for i in 1:samples
        Œ≥‚ÇÇ[i] = Quaternion(sol[v][i])
        u‚ÇÇ[i] = Quaternion(sol[u][i])
        phases[i] = sol[Œ∏][i]
        s[i] = sol[t][i]
        path_s2[i] = sol[w][i]
    end
    Œª = convert_to_cartesian(sol[Œª·µ£] + im * sol[Œª·µ¢])
    Œ≥‚ÇÇ, u‚ÇÇ, phases, Œª, path_s2, s, latex
end


get_u(L::Float64, L‚Ä≤::Float64, s::Float64) = vec(getŒ≥‚ÇÇ(L, L‚Ä≤, s)[2][end])
get_u(L::Float64, L‚Ä≤::Float64, s::Num) = get_u(L, L‚Ä≤, s)
get_u(L::Float64, L‚Ä≤::Float64, s::SymbolicUtils.BasicSymbolic{Real}) = get_u(L, L‚Ä≤, s)
@register_symbolic get_u(L::Float64, L‚Ä≤::Float64, s::Num)::Vector{Float64}
@register_symbolic get_u(L::Float64, L‚Ä≤::Float64, s::SymbolicUtils.BasicSymbolic{Real})::Vector{Float64}


"""
    getŒ≥‚ÇÉ(L, L‚Ä≤)

Get path Œ≥‚ÇÉ with the given integration interval [`L`,`L‚Ä≤`] along paths of type Œ≥‚ÇÇ.
Rupert Way (2008)
"""
function getŒ≥‚ÇÉ(L::Float64, L‚Ä≤::Float64)
    u‚ÇÄ = get_u(L, L‚Ä≤, L)
    v‚ÇÄ = vec(normalize(u‚ÇÄ))
    w‚ÇÄ = œÄmap(Quaternion(v‚ÇÄ))
    m‚ÇÄ = norm(u‚ÇÄ)
    # Define our parameters
    @parameters K‚ÇÉ[1:4,1:4]=K(3) Œ¥=(2œÄ / 10000)
    # Define our state variables: state(t) = initial condition
    @variables t
    @variables u(t)[1:4]=u‚ÇÄ
    @variables u‚Çõ(t)[1:4]=u‚ÇÄ
    @variables v(t)[1:4]=v‚ÇÄ
    @variables w(t)[1:3]=w‚ÇÄ
    @variables m(t)=m‚ÇÄ
    @variables Œ∏(t)=0

    # Define our differential: takes the derivative with respect to `t`
    D = Differential(t)

    # Define the differential equations
    eqs = [u .~ get_u(L, L‚Ä≤, t)[1:4]
           u‚Çõ .~ (get_u(L, L‚Ä≤, t + Œ¥)[1:4] - get_u(L, L‚Ä≤, t - Œ¥)[1:4]) ./ 2Œ¥
           D(Œ∏) ~ imag([u[1] + u[3] * im; u[2] + u[4] * im]' * [u‚Çõ[1] + u‚Çõ[3] * im; u‚Çõ[2] + u‚Çõ[4] * im]) / (u' * u)
           m ~ sqrt·µ£(sum(abs.([u[1] + u[3] * im; u[2] + u[4] * im]).^2), 0)
           v ~ u ./ m
           w[3] ~ real(conj(v[1] + v[3] * im) * (v[2] + v[4] * im) + (v[1] + v[3] * im) * conj(v[2]) + v[4] * im)
           w[2] ~ real(im * (conj(v[1] + v[3] * im) * (v[2] + v[4] * im) - (v[1] + v[3] * im) * conj(v[2] + v[4] * im)))
           w[1] ~ real(abs(v[1] + v[3] * im)^2 - abs(v[2] + v[4] * im)^2)]

    latex = latexify(eqs)

    # Bring these pieces together into an ODESystem with independent variable t
    @named sys = ODESystem(eqs, t)

    # Symbolically Simplify the System
    simpsys = structural_simplify(sys)

   # latexify(simpsys)

    # Convert from a symbolic to a numerical problem to simulate
    tspan = (0, 2œÄ)
    prob = ODEProblem(simpsys, [], tspan)

    # Solve the ODE
    sol = solve(prob)
    samples = length(sol[v])
    Œ≥‚ÇÉ = Vector{Quaternion}(undef, samples)
    phases = Vector{Float64}(undef, samples)
    s = Vector{Float64}(undef, samples)
    s2_path = Vector{Vector{Float64}}(undef, samples)
    for i in 1:samples
        Œ≥‚ÇÉ[i] = Quaternion(sol[v][i])
        phases[i] = sol[Œ∏][i]
        s[i] = sol[t][i]
        s2_path = sol[w][i]
    end
    Œ≥‚ÇÉ, phases, s2_path, s, latex
end


Œ≥‚ÇÅ, Œ∏‚ÇÅ, Œª‚ÇÅ, w‚ÇÅ, t‚ÇÅ, latex1 = getŒ≥‚ÇÅ(0.0, 2œÄ)
steps_number = length(t‚ÇÅ)
Œ≥‚ÇÇ = Vector{Vector{Quaternion}}(undef, steps_number)
Œ∏‚ÇÇ = Vector{Vector{Float64}}(undef, steps_number)
Œª_array = []
for i in 1:steps_number
    _Œ≥, _u, _Œ∏, _Œª, _w, _t, _latex2 = getŒ≥‚ÇÇ(L, L‚Ä≤, t‚ÇÅ[i])
    push!(Œª_array, _Œª)
    Œ≥‚ÇÇ[i] = _Œ≥
    Œ∏‚ÇÇ[i] = _Œ∏
end
Œ≥‚ÇÉ, Œ∏‚ÇÉ, s2_path‚ÇÉ, t‚ÇÉ, latex3 = getŒ≥‚ÇÉ(L, L‚Ä≤)

makefigure() = GLMakie.Figure(resolution = resolution)
fig = GLMakie.with_theme(makefigure, GLMakie.theme_black())
pl = GLMakie.PointLight(GLMakie.Point3f(0), GLMakie.RGBf(20, 20, 20))
al = GLMakie.AmbientLight(GLMakie.RGBf(0.9, 0.9, 0.9))
lscene = GLMakie.LScene(fig[1, 1], show_axis=true, scenekw = (resolution = resolution, lights = [pl, al], backgroundcolor=:black, clear=true))

starman = FileIO.load("data/Starman_3.stl")
starman_sprite = GLMakie.mesh!(
    lscene,
    starman,
    color = [tri[1][2] for tri in starman for i in 1:3],
    colormap = GLMakie.Reverse(:Spectral)
)
scale = 1 / 400
GLMakie.scale!(starman_sprite, scale, scale, scale)

cam = GLMakie.camera(lscene.scene) # this is how to access the scenes camera
# eyeposition = GLMakie.Vec3f(cam.eyeposition[]...)
eyeposition = GLMakie.Vec3f(1, 1, 1)
lookat = GLMakie.Vec3f(0, 0, 0)
up = GLMakie.Vec3f(0, 0, 1)
GLMakie.update_cam!(lscene.scene, eyeposition, lookat, up)

colorref = FileIO.load("data/basemap_color.png")
basemap_color = FileIO.load("data/basemap_mask1.png")
## Load the Natural Earth data
attributespath = "./data/gdp/geometry-attributes.csv"
nodespath = "./data/gdp/geometry-nodes.csv"
countries = loadcountries(attributespath, nodespath)
boundary_names = ["United States of America", "South Africa", "Iran", "Turkey", "Australia", "New Zealand"]
boundary_nodes = Vector{Vector{Vector{Float64}}}()
for i in eachindex(countries["name"])
    for name in boundary_names
        if countries["name"][i] == name
            push!(boundary_nodes, countries["nodes"][i])
        end
    end
end
boundary_colors = []
boundary_w = []
for i in eachindex(boundary_nodes)
    color = getcolor(boundary_nodes[i], colorref, Œ±)
    push!(boundary_colors, color)
    w = [œÑmap(boundary_nodes[i][j]) for j in eachindex(boundary_nodes[i])]
    push!(boundary_w, w)
    whirl1 = Whirl(lscene, w, [float(œÄ) for _ in 1:length(w)], [0.0 for _ in 1:length(w)], segments, color, transparency = true)
end
# Whirl(lscene, Œ≥‚ÇÅ, [0.0 for _ in Œ≥‚ÇÅ], [2œÄ for _ in Œ≥‚ÇÅ], segments, getcolor(œÄmap.(Œ≥‚ÇÅ), colorref, Œ±), transparency = true)
# whirl = Whirl(lscene, Œ≥‚ÇÉ, [0.0 for i in Œ≥‚ÇÉ], [2œÄ for _ in Œ≥‚ÇÉ], segments, getcolor(œÄmap.(Œ≥‚ÇÉ), colorref, Œ±), transparency = true)
# whirls = []
# for i in 1:steps_number
#     c = GLMakie.RGBAf(convert_hsvtorgb([i / steps_number * 360; 1; 1])..., Œ±)
#     whirl = Whirl(lscene, Œ≥‚ÇÇ[i], [0.0 for i in Œ≥‚ÇÇ[i]], [Œ∏‚ÇÇ[i][begin] for _ in Œ≥‚ÇÇ[i]], segments, c, transparency = true)
#     push!(whirls, whirl)
# end
# w = map(x -> x[end], Œ≥‚ÇÇ)
# Whirl(lscene, w, [0.0 for _ in w], [2œÄ for _ in w], segments, getcolor(œÄmap.(w), colorref, 0.1), transparency = true)
basemap1 = Basemap(lscene, x -> G(0, œÑmap(x)), segments, basemap_color, transparency = true)
basemap2 = Basemap(lscene, x -> G(0, œÑmap(x)), segments, basemap_color, transparency = true)
basemap3 = Basemap(lscene, x -> G(œÄ, œÑmap(x)), segments, basemap_color, transparency = true)
points1 = GLMakie.Observable(GLMakie.Point3f[]) # Signal that can be used to update plots efficiently
colors1 = GLMakie.Observable(Int[])
lines1 = GLMakie.lines!(lscene, points1, linewidth = linewidth, color = colors1, colormap = :jet, transparency = false)
points2 = [GLMakie.Observable(GLMakie.Point3f[]) for _ in 1:steps_number]
colors2 = [GLMakie.Observable(Int[]) for _ in 1:steps_number]
lines2 = [GLMakie.lines!(lscene, points2[i], linewidth = linewidth, color = colors2[i], colormap = :jet, transparency = false) for i in 1:steps_number]
points3 = GLMakie.Observable(GLMakie.Point3f[]) # Signal that can be used to update plots efficiently
colors3 = GLMakie.Observable(Int[])
lines3 = GLMakie.lines!(lscene, points3, linewidth = 3linewidth, color = colors3, colormap = :plasma, transparency = false)
memo1 = []
memo2 = [[] for _ in 1:steps_number]
memo3 = []

function step1(progress)
    i = max(1, Int(floor(progress * steps_number)))
    p = project(Œ≥‚ÇÅ[i])
    if i ‚àà memo1
        return p
    else
        push!(memo1, i)
    end
    rainbowcolors = [GLMakie.RGBAf(convert_hsvtorgb([i / steps_number * 360; 1; 1])..., Œ±) for i in 1:steps_number]
    color1 = GLMakie.RGBAf(convert_hsvtorgb([progress * 360; 1; 1])..., 0.9)
    red, green, blue = GLMakie.RGBAf(1, 0, 0, 1), GLMakie.RGBAf(0, 1, 0, 1), GLMakie.RGBAf(0, 0, 1, 1)
    linecolor = [red, green, blue]
    arrowcolor = [red, green, blue]
    w = œÄmap(Œ≥‚ÇÅ[i])
    GLMakie.meshscatter!([w[1]], [w[2]], [w[3]], markersize = 2markersize, color = rainbowcolors[i], transparency = true)
    basepoints = map(x -> project(x), Œ≥‚ÇÅ)
    px = [basepoints[j][1] for j in 1:i]
    py = [basepoints[j][2] for j in 1:i]
    pz = [basepoints[j][3] for j in 1:i]
    GLMakie.meshscatter!(px, py, pz, markersize = markersize, color = rainbowcolors[1:i], transparency = true)
    tail = [GLMakie.Point3f(p...) for _ in 1:3]
    head = [GLMakie.Point3f(project(K(3) * Œ≥‚ÇÅ[i])) * 0.2, GLMakie.Point3f(project(K(1) * Œ≥‚ÇÅ[i])) * 0.2, GLMakie.Point3f(project(K(2) * Œ≥‚ÇÅ[i])) * 0.2]
    GLMakie.arrows!(lscene, tail, head, fxaa=true, linecolor = linecolor, arrowcolor = arrowcolor, linewidth = 0.01, arrowsize = arrowsize, transparency = true)
    GLMakie.meshscatter!([p[1]], [p[2]], [p[3]], markersize = markersize, color = color1, transparency = true)
    update!(basemap1, x -> G(Œ∏‚ÇÅ[i], œÑmap(x)))
    push!(points1[], tail[1])
    frame = max(1, Int(floor(progress * frames_number)))
    push!(colors1[], frame)
    lines1.colorrange = (0, frame) # update plot attribute directly
    notify(points1); notify(colors1) # tell points and colors that their value has been updated
    GLMakie.rotate!(starman_sprite, GLMakie.Vec3f(zÃÇ), Œ∏‚ÇÅ[i])
    axis = Float64.(normalize(project(K(3) * Œ≥‚ÇÅ[i])))
    rotation_angle, rotation_axis = getrotation(zÃÇ, axis)
    GLMakie.rotate!(starman_sprite, GLMakie.Vec3f(rotation_axis), rotation_angle)
    GLMakie.translate!(starman_sprite, GLMakie.Point3f(p))
    # update!(whirl, color1)
    p
end


function step2(progress)
    p = [0.0; 0.0; 0.0]
    N = 0
    phase = 0.0
    for i in 1:steps_number
        _samples = length(Œ≥‚ÇÇ[i])
        j = max(1, Int(floor(progress * _samples)))
        _p = project(Œ≥‚ÇÇ[i][j])
        N += 1
        p += _p
        phase += Œ∏‚ÇÇ[i][j]
        if j ‚àà memo2[i]
            continue
        else
            push!(memo2[i], j)
        end
        push!(points2[i][], _p)
        frame = max(1, Int(floor(progress * frames_number)))
        push!(colors2[i][], frame)
        lines2[i].colorrange = (0, frame) # update plot attribute directly
        notify(points2[i]); notify(colors2[i]) # tell points and colors that their value has been updated
        # update!(whirls[i], Œ≥‚ÇÇ[i], [0.0 for _ in 1:_samples] ,[-Œ∏‚ÇÇ[i][j] for _ in 1:_samples])
        # c = GLMakie.RGBAf(convert_hsvtorgb([i * steps_number * 360; 1; 1])..., Œ± / 2)
        # update!(whirls[i], c)
    end
    update!(basemap1, x -> G(Œ∏‚ÇÇ[end][end], œÑmap(x)))
    i = max(1, Int(floor(progress * length(Œ≥‚ÇÇ[end]))))
    GLMakie.rotate!(starman_sprite, GLMakie.Vec3f(zÃÇ), Œ∏‚ÇÇ[end][i])
    axis = Float64.(normalize(project(K(3) * Œ≥‚ÇÇ[end][i])))
    rotation_angle, rotation_axis = getrotation(zÃÇ, axis)
    GLMakie.rotate!(starman_sprite, GLMakie.Vec3f(rotation_axis), rotation_angle)
    GLMakie.translate!(starman_sprite, GLMakie.Point3f(project(Œ≥‚ÇÇ[end][i])))
    p ./ N
end


function step3(progress)
    Œ± = 0.9
    i = max(1, Int(floor(progress * length(Œ≥‚ÇÉ))))
    p = project(Œ≥‚ÇÉ[i])
    if i ‚àà memo3
        return p
    else
        push!(memo3, i)
    end
    w = œÄmap(Œ≥‚ÇÉ[i])
    rainbowcolors = [GLMakie.RGBAf(convert_hsvtorgb([i / length(Œ≥‚ÇÉ) * 360; 1; 1])..., Œ±) for i in 1:length(Œ≥‚ÇÉ)]
    GLMakie.meshscatter!([w[1]], [w[2]], [w[3]], markersize = 2markersize, color = rainbowcolors[i], transparency = true)
    push!(points3[], p)
    frame = max(1, Int(floor(progress * frames_number)))
    push!(colors3[], frame)
    lines3.colorrange = (0, frame) # update plot attribute directly
    notify(points3); notify(colors3) # tell points and colors that their value has been updated
    color1 = GLMakie.RGBAf(convert_hsvtorgb([progress * 360; 1; 1])..., Œ±)
    red, green, blue = GLMakie.RGBAf(1, 0, 0, 1), GLMakie.RGBAf(0, 1, 0, 1), GLMakie.RGBAf(0, 0, 1, 1)
    linecolor = [red, green, blue]
    arrowcolor = [red, green, blue]
    tail = [GLMakie.Point3f(p...) for _ in 1:3]
    head = [GLMakie.Point3f(project(K(3) * Œ≥‚ÇÉ[i])), GLMakie.Point3f(project(K(1) * Œ≥‚ÇÉ[i])), GLMakie.Point3f(project(K(2) * Œ≥‚ÇÉ[i]))]
    GLMakie.arrows!(lscene, tail, head, fxaa=true, linecolor = linecolor, arrowcolor = arrowcolor, linewidth = 0.01, arrowsize = arrowsize, transparency = false)
    GLMakie.meshscatter!([p[1]], [p[2]], [p[3]], markersize = markersize, color = color1, transparency = false)
    GLMakie.rotate!(starman_sprite, GLMakie.Vec3f(zÃÇ), Œ∏‚ÇÉ[i])
    axis = Float64.(normalize(project(K(3) * Œ≥‚ÇÉ[i])))
    rotation_angle, rotation_axis = getrotation(zÃÇ, axis)
    GLMakie.rotate!(starman_sprite, GLMakie.Vec3f(rotation_axis), rotation_angle)
    GLMakie.translate!(starman_sprite, GLMakie.Point3f(project(Œ≥‚ÇÉ[i])))
    update!(basemap1, x -> G(Œ∏‚ÇÉ[i], œÑmap(x)))
    p
end


GLMakie.record(fig, joinpath("gallery", "$modelname.mp4"), 1:frames_number) do frame
    println("Frame: $frame")
    progress = frame / frames_number
    distance = 2œÄ / 3
    _segments = 4
    if progress ‚â§ 1 / _segments
        _progress = _segments * progress
        p = step1(_progress)
    end
    if 1 / _segments < progress ‚â§ 2 / _segments
        _progress = _segments * (progress - 1 / _segments)
        p = step2(_progress)
    end
    if 2 / _segments < progress ‚â§ 3 / _segments
        _progress = _segments * (progress - 2 / _segments)
        p = step3(_progress)
    end
    if 3 / _segments < progress ‚â§ 4 / _segments
        _progress = _segments * (progress - 3 / _segments)
        i = max(1, Int(floor(_progress * steps_number)))
        p = project(Œ≥‚ÇÉ[end])
        distance += 1e-2
    end
    
    global lookat = 0.9 * lookat + 0.1 * GLMakie.Vec3f(p...)
    up = GLMakie.Vec3f(0, 0, 1)
    azimuth = œÄ + œÄ / 4 + 0.3 * sin(2œÄ * progress) # set the view angle of the axis
    eyeposition = GLMakie.Vec3f(distance .* convert_to_cartesian([1; azimuth; œÄ / 6])...)
    GLMakie.update_cam!(lscene.scene, eyeposition, lookat, up)
end
