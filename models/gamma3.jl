import FileIO
import DataFrames
import CSV
import GLMakie
using LinearAlgebra
using ModelingToolkit, DifferentialEquations, Latexify
using Porta


resolution = (1920, 1080)
segments = 60
frames_number = 360

r‚ÇÅ = 0.8 # experiments: 1-6
Œª‚ÇÅ = 1 + 0.2 * im # experiment 1
Œª‚ÇÇ = im # experiment 2
Œª‚ÇÉ = 2 + im # experiment 3
Œª‚ÇÑ = 0 # experiment 4
Œª‚ÇÖ = 1 # experiment 5
Œª‚ÇÜ = -im # experiment 6

r‚Çá = 0.5 # experiment 7
Œª‚Çá = -im # experiment 7

r‚Çà = 0.8 # experiment 8
Œª‚Çà = 2 - im # experiment 8

r‚ÇÄ = r‚ÇÅ
Œª‚ÇÄ = Œª‚ÇÇ
œï‚ÇÄ = 0.0

operator = imag(Œª‚ÇÄ) ‚â• 0 ? "+" : "-"
version = "r‚ÇÄ=$(r‚ÇÄ)_Œª‚ÇÄ=$(float(real(Œª‚ÇÄ)))_$(operator)_ùëñ$(abs(float(imag(Œª‚ÇÄ))))"
modelname = "gamma3_$version"
L = 10.0
L‚Ä≤ = -L
zÃÇ = [0.0; 0.0; 1.0]
Œ± = 0.1
markersize = 0.01
linewidth = 5.0
arrowsize = GLMakie.Vec3f(0.02, 0.02, 0.04)

getŒª(s) = Œª‚ÇÄ + r‚ÇÄ * exp(im * (s + œï‚ÇÄ))
getŒª‚Çõ(s, _r) = im * _r * exp(im * (s + œï‚ÇÄ))
getŒº(s) = ‚àö(getŒª(s) + 1)
getf(x) = (3 / 2) * sech(x / 2)^2
getA(x, s) = [0 1; getŒª(s) + 1 - 2getf(x) 0]
sqrt·µ£(r::Real, i::Real) = real(‚àö(r + im * i))
sqrt·µ¢(r::Real, i::Real) = imag(‚àö(r + im * i))
sqrt·µ£(r::Num, i::Num) = real(‚àö(r + im * i))
sqrt·µ¢(r::Num, i::Num) = imag(‚àö(r + im * i))
@register_symbolic sqrt·µ£(r, i)
@register_symbolic sqrt·µ¢(r, i)


"""
    getŒ≥‚ÇÅ(L, L‚Ä≤)

Get path Œ≥‚ÇÅ by integating a connection 1-form around a loop in Œª-space with the given interval [`L`,`L‚Ä≤`].
Rupert Way (2008)
"""
function getŒ≥‚ÇÅ(L::Float64, L‚Ä≤::Float64)
    s‚ÇÄ = L
    u‚ÇÄ = Quaternion([1.0; -‚àö(getŒª(s‚ÇÄ) + 1)])
    u‚Çó‚ÇÄ = Quaternion([0.0; -1 / 2(‚àö(getŒª(s‚ÇÄ) + 1))])
    v‚ÇÄ = normalize(u‚ÇÄ)
    w‚ÇÄ = œÄmap(v‚ÇÄ)
    Œª‚Çõ‚ÇÄ = getŒª‚Çõ(s‚ÇÄ, r‚ÇÄ)
    Œ∏‚ÇÄ = 0.0
    m‚ÇÄ = norm(u‚ÇÄ)
    # TDOO: define Œª‚Çõ in terms of the D differential operator
    # Define our state variables: state(t) = initial condition
    @variables t
    @variables Œª·µ£(t)=real(getŒª(L))
    @variables Œª·µ¢(t)=imag(getŒª(L))
    @variables Œª‚Çõ·µ£(t)=real(Œª‚Çõ‚ÇÄ)
    @variables Œª‚Çõ·µ¢(t)=imag(Œª‚Çõ‚ÇÄ)
    @variables u(t)[1:4]=vec(u‚ÇÄ)
    @variables u‚Çó(t)[1:4]=vec(u‚Çó‚ÇÄ)
    @variables v(t)[1:4]=vec(v‚ÇÄ)
    @variables w(t)[1:3]=w‚ÇÄ
    @variables Œ∏(t)=Œ∏‚ÇÄ
    @variables m(t)=m‚ÇÄ
    # Define our parameters
    @parameters r::Float64=r‚ÇÄ œï::Float64=œï‚ÇÄ
    # Define our differential: takes the derivative with respect to `t`
    D = Differential(t)
    # Define the differential equations
    eqs = [Œª·µ£ ~ real(getŒª(t))
           Œª·µ¢ ~ imag(getŒª(t))
           Œª‚Çõ·µ£ ~ real(getŒª‚Çõ(t, r))
           Œª‚Çõ·µ¢ ~ imag(getŒª‚Çõ(t, r))
           u[1] ~ 1.0
           u[2] ~ -sqrt·µ£(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))
           u[3] ~ 0.0
           u[4] ~ -sqrt·µ¢(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))
           u‚Çó[1] ~ 0.0
           u‚Çó[2] ~ real(-1 / 2(sqrt·µ£(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1)) + im * sqrt·µ¢(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))))
           u‚Çó[3] ~ 0.0
           u‚Çó[4] ~ imag(-1 / 2(sqrt·µ£(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1)) + im * sqrt·µ¢(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))))
           m ~ sqrt·µ£(sum(abs.([u[1] + u[3] * im; u[2] + u[4] * im]).^2), 0.0)
           v ~ u ./ m
           w[3] ~ real(conj(v[1] + v[3] * im) * (v[2] + v[4] * im) + (v[1] + v[3] * im) * conj(v[2]) + v[4] * im)
           w[2] ~ real(im * (conj(v[1] + v[3] * im) * (v[2] + v[4] * im) - (v[1] + v[3] * im) * conj(v[2] + v[4] * im)))
           w[1] ~ real(abs(v[1] + v[3] * im)^2 - abs(v[2] + v[4] * im)^2)
           D(Œ∏) ~ imag(u' * u‚Çó * (Œª‚Çõ·µ£ + Œª‚Çõ·µ¢ * im)) / (u' * u)]
    latex = latexify(eqs)
    # Bring these pieces together into an ODESystem with independent variable t
    @named sys = ODESystem(eqs, t)
    # Symbolically Simplify the System
    simpsys = structural_simplify(sys)
    # Convert from a symbolic to a numerical problem to simulate
    tspan = (L, L‚Ä≤)
    prob = ODEProblem(simpsys, [], tspan)
    # Solve the ODE
    sol = solve(prob)
    samples = length(sol[v])
    Œ≥‚ÇÅ = Vector{Quaternion}(undef, samples)
    phases = Vector{Float64}(undef, samples)
    path_Œª = Vector{Vector{Float64}}(undef, samples)
    s = Vector{Float64}(undef, samples)
    path_s2 = Vector{Vector{Float64}}(undef, samples)
    for i in 1:samples
        Œ≥‚ÇÅ[i] = Quaternion(sol[v][i])
        path_Œª[i] = convert_to_cartesian(sol[Œª·µ£][i] + im * sol[Œª·µ¢][i])
        phases[i] = sol[Œ∏][i]
        s[i] = sol[t][i]
        path_s2[i] = sol[w][i]
    end
    Œ≥‚ÇÅ, phases, path_Œª, path_s2, s, latex
end


"""
    getŒ≥‚ÇÇ(L, L‚Ä≤, s‚ÇÄ)

Get path Œ≥‚ÇÇ by integating a connection 1-form in the x direction with the given bounds [`L`,`L‚Ä≤`] and a fixed value for Œª `s‚ÇÄ`.
Rupert Way (2008)
"""
function getŒ≥‚ÇÇ(L::Float64, L‚Ä≤::Float64, s‚ÇÄ::Float64)
    Œº‚ÇÄ = getŒº(s‚ÇÄ)
    u‚ÇÄ = Quaternion([1.0; -Œº‚ÇÄ])
    Œ∏‚ÇÄ = 0.0
    v‚ÇÄ = normalize(u‚ÇÄ)
    w‚ÇÄ = œÄmap(v‚ÇÄ)
    m‚ÇÄ = norm(u‚ÇÄ)
    f‚ÇÄ = getf(s‚ÇÄ)
    Œª·µ£‚ÇÄ = real(getŒª(s‚ÇÄ))
    Œª·µ¢‚ÇÄ = imag(getŒª(s‚ÇÄ))
    # Define our state variables: state(t) = initial condition
    @variables t
    @variables f(t)=f‚ÇÄ
    @variables Œº·µ£(t)=real(Œº‚ÇÄ)
    @variables Œº·µ¢(t)=imag(Œº‚ÇÄ)
    @variables u(t)[1:4]=vec(u‚ÇÄ)
    @variables v(t)[1:4]=vec(v‚ÇÄ)
    @variables w(t)[1:3]=w‚ÇÄ
    @variables Œ∏(t)=Œ∏‚ÇÄ
    @variables m(t)=m‚ÇÄ
    # Define our parameters
    @parameters Œª·µ£::Float64=Œª·µ£‚ÇÄ Œª·µ¢::Float64=Œª·µ¢‚ÇÄ
    # Define our differential: takes the derivative with respect to `t`
    D = Differential(t)
    # Define the differential equations
    eqs = [Œº·µ£ ~ sqrt·µ£(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))
           Œº·µ¢ ~ sqrt·µ¢(real(Œª·µ£ + Œª·µ¢ * im + 1), imag(Œª·µ£ + Œª·µ¢ * im + 1))
           f ~ getf(t)
           D(u[1]) ~ real( ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] + [Œº·µ£ + Œº·µ¢ * im 0; 0 Œº·µ£ + Œº·µ¢ * im]) * [u[1] + u[3] * im; u[2] + u[4] * im] )[1]
           D(u[2]) ~ real( ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] + [Œº·µ£ + Œº·µ¢ * im 0; 0 Œº·µ£ + Œº·µ¢ * im]) * [u[1] + u[3] * im; u[2] + u[4] * im] )[2]
           D(u[3]) ~ imag( ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] + [Œº·µ£ + Œº·µ¢ * im 0; 0 Œº·µ£ + Œº·µ¢ * im]) * [u[1] + u[3] * im; u[2] + u[4] * im] )[1]
           D(u[4]) ~ imag( ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] + [Œº·µ£ + Œº·µ¢ * im 0; 0 Œº·µ£ + Œº·µ¢ * im]) * [u[1] + u[3] * im; u[2] + u[4] * im] )[2]
           D(Œ∏) ~ imag(([u[1] + u[3] * im u[2] + u[4] * im] * ([0 1; (Œª·µ£ + Œª·µ¢ * im) + 1 - 2f 0] * [u[1] + u[3] * im; u[2] + u[4] * im]))[1]) / (u' * u)
           m ~ sqrt·µ£(sum(abs.([u[1] + u[3] * im; u[2] + u[4] * im]).^2), 0)
           v ~ u ./ m
           w[3] ~ real(conj(v[1] + v[3] * im) * (v[2] + v[4] * im) + (v[1] + v[3] * im) * conj(v[2]) + v[4] * im)
           w[2] ~ real(im * (conj(v[1] + v[3] * im) * (v[2] + v[4] * im) - (v[1] + v[3] * im) * conj(v[2] + v[4] * im)))
           w[1] ~ real(abs(v[1] + v[3] * im)^2 - abs(v[2] + v[4] * im)^2)]
    latex = latexify(eqs)
    # Bring these pieces together into an ODESystem with independent variable t
    @named sys = ODESystem(eqs, t)
    # Symbolically Simplify the System
    simpsys = structural_simplify(sys)
    # Convert from a symbolic to a numerical problem to simulate
    tspan = (L, L‚Ä≤)
    prob = ODEProblem(simpsys, [], tspan)
    # Solve the ODE
    sol = solve(prob)
    samples = length(sol[v])
    Œ≥‚ÇÇ = Vector{Quaternion}(undef, samples)
    phases = Vector{Float64}(undef, samples)
    s = Vector{Float64}(undef, samples)
    path_s2 = Vector{Vector{Float64}}(undef, samples)
    for i in 1:samples
        Œ≥‚ÇÇ[i] = Quaternion(sol[v][i])
        phases[i] = sol[Œ∏][i]
        s[i] = sol[t][i]
        path_s2[i] = sol[w][i]
    end
    Œª = convert_to_cartesian(sol[Œª·µ£] + im * sol[Œª·µ¢])
    Œ≥‚ÇÇ, phases, Œª, path_s2, s, latex
end


"""
    getŒ≥‚ÇÉ(L, L‚Ä≤)

Get path Œ≥‚ÇÉ with the given integration interval [`L`,`L‚Ä≤`], which defaults to (0, 2œÄ].
Rupert Way (2008)
"""
function getŒ≥‚ÇÉ(L::Float64 = 0.0, L‚Ä≤::Float64 = 2œÄ)
    u‚ÇÄ = get_u_L‚Ä≤_Œª_s(L, L‚Ä≤, L)
    v‚ÇÄ = vec(u‚ÇÄ)
    # Define our state variables: state(t) = initial condition
    @variables t
    @variables u1(t)=v‚ÇÄ[1] u2(t)=v‚ÇÄ[2] u3(t)=v‚ÇÄ[3] u4(t)=v‚ÇÄ[4]
    @variables w1(t)=v‚ÇÄ[1] w2(t)=v‚ÇÄ[2] w3(t)=v‚ÇÄ[3] w4(t)=v‚ÇÄ[4]
    @variables v(t)[1:4]=v‚ÇÄ
    @variables Œ∏(t)=0
    @variables vhat(t)[1:4]=v‚ÇÄ
    @variables vdot(t)[1:4]=vec(Quaternion(im .* [u‚ÇÄ.a + im * u‚ÇÄ.c; u‚ÇÄ.b + im * u‚ÇÄ.d]))

    # Define our parameters
    @parameters K‚ÇÉ[1:4,1:4]=K(3) Œ¥=(2œÄ / 100000000)

    # Define our differential: takes the derivative with respect to `t`
    D = Differential(t)

    # Define the differential equations
    eqs = [u1 ~ get_u_L‚Ä≤_Œª_s1(L, L‚Ä≤, t + Œ¥)
           u2 ~ get_u_L‚Ä≤_Œª_s2(L, L‚Ä≤, t + Œ¥)
           u3 ~ get_u_L‚Ä≤_Œª_s3(L, L‚Ä≤, t + Œ¥)
           u4 ~ get_u_L‚Ä≤_Œª_s4(L, L‚Ä≤, t + Œ¥)
           w1 ~ get_u_L‚Ä≤_Œª_s1(L, L‚Ä≤, t - Œ¥)
           w2 ~ get_u_L‚Ä≤_Œª_s2(L, L‚Ä≤, t - Œ¥)
           w3 ~ get_u_L‚Ä≤_Œª_s3(L, L‚Ä≤, t - Œ¥)
           w4 ~ get_u_L‚Ä≤_Œª_s4(L, L‚Ä≤, t - Œ¥)
           D(v[1]) ~ (u1 - w1) / 2Œ¥
           D(v[2]) ~ (u2 - w2) / 2Œ¥
           D(v[3]) ~ (u3 - w3) / 2Œ¥
           D(v[4]) ~ (u4 - w4) / 2Œ¥
           vhat[1] ~ normalize1(v...)
           vhat[2] ~ normalize2(v...)
           vhat[3] ~ normalize3(v...)
           vhat[4] ~ normalize4(v...)
           vdot[1] ~ normalize1(D(v[1]), D(v[2]), D(v[3]), D(v[4])) 
           vdot[2] ~ normalize2(D(v[1]), D(v[2]), D(v[3]), D(v[4])) 
           vdot[3] ~ normalize3(D(v[1]), D(v[2]), D(v[3]), D(v[4])) 
           vdot[4] ~ normalize4(D(v[1]), D(v[2]), D(v[3]), D(v[4])) 
           D(Œ∏) ~ -dot(K‚ÇÉ * vhat, vdot)]

    # latexify(eqs)

    # Bring these pieces together into an ODESystem with independent variable t
    @named sys = ODESystem(eqs, t)

    # Symbolically Simplify the System
    simpsys = structural_simplify(sys)

    latexify(simpsys)

    # Convert from a symbolic to a numerical problem to simulate
    tspan = (0, 2œÄ)
    prob = ODEProblem(simpsys, [], tspan)

    # Solve the ODE
    sol = solve(prob)
    samples = length(sol[v])
    Œ≥‚ÇÉ = Vector{Quaternion}(undef, samples)
    phases = Vector{Float64}(undef, samples)
    s = Vector{Float64}(undef, samples)
    for i in 1:samples
        Œ≥‚ÇÉ[i] = Quaternion(sol[v][i])
        phases[i] = sol[Œ∏][i]
        s[i] = sol[t][i]
    end
    Œ≥‚ÇÉ, phases, s
end


Œ≥‚ÇÅ, Œ∏‚ÇÅ, Œª‚ÇÅ, w‚ÇÅ, t‚ÇÅ, latex1 = getŒ≥‚ÇÅ(0.0, 2œÄ)
samples1 = length(t‚ÇÅ)
steps_number = samples1
Œ≥‚ÇÇ = Vector{Vector{Quaternion}}(undef, steps_number)
Œ∏‚ÇÇ = Vector{Vector{Float64}}(undef, steps_number)
Œª_array = []
for i in 1:steps_number
    s‚ÇÄ = t‚ÇÅ[i]
    _Œ≥, _Œ∏, _Œª, _w, _t, _latex = getŒ≥‚ÇÇ(L, L‚Ä≤, s‚ÇÄ)
    push!(Œª_array, _Œª)
    Œ≥‚ÇÇ[i] = _Œ≥
    Œ∏‚ÇÇ[i] = _Œ∏
end

makefigure() = GLMakie.Figure(resolution = resolution)
fig = GLMakie.with_theme(makefigure, GLMakie.theme_black())
pl = GLMakie.PointLight(GLMakie.Point3f(0), GLMakie.RGBf(20, 20, 20))
al = GLMakie.AmbientLight(GLMakie.RGBf(0.9, 0.9, 0.9))
lscene = GLMakie.LScene(fig[1, 1], show_axis=true, scenekw = (resolution = resolution, lights = [pl, al], backgroundcolor=:black, clear=true))

starman = FileIO.load("data/SpaceX_s_Starman_desk_toy_2804270/files/Starman_3.stl")
starman_sprite = GLMakie.mesh!(
    lscene,
    starman,
    color = [tri[1][2] for tri in starman for i in 1:3],
    colormap = GLMakie.Reverse(:Spectral)
)
scale = 1 / 600
GLMakie.scale!(starman_sprite, scale, scale, scale)

cam = GLMakie.camera(lscene.scene) # this is how to access the scenes camera
# eyeposition = GLMakie.Vec3f(cam.eyeposition[]...)
eyeposition = GLMakie.Vec3f(1, 1, 1)
lookat = GLMakie.Vec3f(0, 0, 0)
up = GLMakie.Vec3f(0, 0, 1)
GLMakie.update_cam!(lscene.scene, eyeposition, lookat, up)

colorref = FileIO.load("data/basemap_color.png")
basemap_color = FileIO.load("data/basemap_mask1.png")
## Load the Natural Earth data
attributespath = "./data/gdp/geometry-attributes.csv"
nodespath = "./data/gdp/geometry-nodes.csv"
countries = loadcountries(attributespath, nodespath)
boundary_names = ["United States of America", "South Africa", "Iran", "Turkey", "Australia", "New Zealand"]
boundary_nodes = Vector{Vector{Vector{Float64}}}()
for i in eachindex(countries["name"])
    for name in boundary_names
        if countries["name"][i] == name
            push!(boundary_nodes, countries["nodes"][i])
        end
    end
end
boundary_colors = []
boundary_w = []
for i in eachindex(boundary_nodes)
    color = getcolor(boundary_nodes[i], colorref, Œ±)
    push!(boundary_colors, color)
    w = [œÑmap(boundary_nodes[i][j]) for j in eachindex(boundary_nodes[i])]
    push!(boundary_w, w)
    whirl1 = Whirl(lscene, w, [0.0 for _ in 1:length(w)], [2œÄ for _ in 1:length(w)], segments, color, transparency = true)
end
Whirl(lscene, Œ≥‚ÇÅ, [0.0 for _ in eachindex(Œ≥‚ÇÅ)], [2œÄ for _ in eachindex(Œ≥‚ÇÅ)], segments, getcolor(œÄmap.(Œ≥‚ÇÅ), colorref, Œ±), transparency = true)
whirls = []
for i in 1:steps_number
    whirl = Whirl(lscene, Œ≥‚ÇÇ[i], [0.0 for _ in eachindex(Œ≥‚ÇÇ[i])], [0.0001 for _ in eachindex(Œ≥‚ÇÇ[i])], segments, getcolor(œÄmap.(Œ≥‚ÇÇ[i]), colorref, Œ±), transparency = true)
    push!(whirls, whirl)
end
basemap1 = Basemap(lscene, x -> G(0, œÑmap(x)), segments, basemap_color, transparency = true)
basemap2 = Basemap(lscene, x -> G(0, œÑmap(x)), segments, basemap_color, transparency = true)
points1 = GLMakie.Observable(GLMakie.Point3f[]) # Signal that can be used to update plots efficiently
colors1 = GLMakie.Observable(Int[])
lines1 = GLMakie.lines!(lscene, points1, linewidth = linewidth, color = colors1, colormap = :jet, transparency = true)
points2 = [GLMakie.Observable(GLMakie.Point3f[]) for _ in 1:steps_number]
colors2 = [GLMakie.Observable(Int[]) for _ in 1:steps_number]
lines2 = [GLMakie.lines!(lscene, points2[i], linewidth = linewidth, color = colors2[i], colormap = :jet, transparency = true) for i in 1:steps_number]
points3 = GLMakie.Observable(GLMakie.Point3f[]) # Signal that can be used to update plots efficiently
colors3 = GLMakie.Observable(Int[])
lines3 = GLMakie.lines!(lscene, points3, linewidth = 3linewidth, color = colors3, colormap = :plasma, transparency = false)
memo1 = []
memo2 = [[] for _ in 1:steps_number]
memo3 = []

function step1(progress)
    i = max(1, Int(floor(progress * samples1)))
    p = project(Œ≥‚ÇÅ[i])
    if i ‚àà memo1
        return p
    else
        push!(memo1, i)
    end
    rainbowcolors = [GLMakie.RGBAf(convert_hsvtorgb([i / samples1 * 360; 1; 1])..., Œ±) for i in 1:samples1]
    color1 = GLMakie.RGBAf(convert_hsvtorgb([progress * 360; 1; 1])..., Œ±)
    color2 = GLMakie.RGBAf(convert_hsvtorgb([progress * 360; 0.5; 0.5])..., Œ±)
    color3 = GLMakie.RGBAf(convert_hsvtorgb([progress * 360; 0.25; 0.25])..., Œ±)
    linecolor = [color1, color2, color3]
    arrowcolor = [color1, color2, color3]
    w = œÄmap(Œ≥‚ÇÅ[i])
    GLMakie.meshscatter!([w[1]], [w[2]], [w[3]], markersize = 2markersize, color = rainbowcolors[i], transparency = true)
    basepoints = map(x -> project(x), Œ≥‚ÇÅ)
    px = [basepoints[j][1] for j in 1:i]
    py = [basepoints[j][2] for j in 1:i]
    pz = [basepoints[j][3] for j in 1:i]
    GLMakie.meshscatter!(px, py, pz, markersize = markersize, color = rainbowcolors[1:i], transparency = true)
    tail = [GLMakie.Point3f(p...) for _ in 1:3]
    head = [GLMakie.Point3f(p + project(K(3) * Œ≥‚ÇÅ[i])), GLMakie.Point3f(p + project(K(1) * Œ≥‚ÇÅ[i])) * 0.5, GLMakie.Point3f(p + project(K(2) * Œ≥‚ÇÅ[i])) * 0.5]
    GLMakie.arrows!(lscene, tail, head, fxaa=true, linecolor = linecolor, arrowcolor = arrowcolor, linewidth = 0.01, arrowsize = arrowsize, transparency = true)
    GLMakie.meshscatter!([p[1]], [p[2]], [p[3]], markersize = markersize, color = color1, transparency = true)
    update!(basemap1, x -> G(Œ∏‚ÇÅ[i], œÑmap(x)))
    push!(points1[], tail[1])
    frame = max(1, Int(floor(progress * frames_number)))
    push!(colors1[], frame)
    lines1.colorrange = (0, frame) # update plot attribute directly
    notify(points1); notify(colors1) # tell points and colors that their value has been updated
    GLMakie.rotate!(starman_sprite, GLMakie.Vec3f(zÃÇ), -2(Œ∏‚ÇÅ[i]))
    axis = Float64.(normalize(project(K(3) * Œ≥‚ÇÅ[i])))
    rotation_angle, rotation_axis = getrotation(zÃÇ, axis)
    GLMakie.rotate!(starman_sprite, GLMakie.Vec3f(rotation_axis), rotation_angle)
    GLMakie.translate!(starman_sprite, GLMakie.Point3f(p))
    p
end


function step2(progress)
    p = [0.0; 0.0; 0.0]
    N = 0
    phase = 0.0
    for i in 1:steps_number
        _samples = length(Œ≥‚ÇÇ[i])
        j = max(1, Int(floor(progress * _samples)))
        _p = project(Œ≥‚ÇÇ[i][j])
        N += 1
        p += _p
        phase += Œ∏‚ÇÇ[i][j]
        if j ‚àà memo2[i]
            continue
        else
            push!(memo2[i], j)
        end
        push!(points2[i][], _p)
        frame = max(1, Int(floor(progress * frames_number)))
        push!(colors2[i][], frame)
        lines2[i].colorrange = (0, frame) # update plot attribute directly
        notify(points2[i]); notify(colors2[i]) # tell points and colors that their value has been updated
        update!(whirls[i], Œ≥‚ÇÇ[i], [0.0 for _ in 1:_samples] ,[Œ∏‚ÇÇ[i][j] for _ in 1:_samples])
    end
    phase = phase / N
    update!(basemap1, x -> G(phase, œÑmap(x)))
    p ./ N
end

function step3(progress)
    i = max(1, Int(floor(progress * steps_number)))
    p = project(Œ≥‚ÇÇ[i][end])
    if i ‚àà memo3
        return p
    else
        push!(memo3, i)
    end
    push!(points3[], p)
    frame = max(1, Int(floor(progress * frames_number)))
    push!(colors3[], frame)
    lines3.colorrange = (0, frame) # update plot attribute directly
    notify(points3); notify(colors3) # tell points and colors that their value has been updated
    update!(basemap1, x -> G(Œ∏‚ÇÇ[i][end], œÑmap(x)))
    p
end


GLMakie.record(fig, joinpath("gallery", "$modelname.mp4"), 1:frames_number) do frame
    println("Frame: $frame")
    progress = frame / frames_number
    distance = œÄ / 2
    _segments = 4
    if progress ‚â§ 1 / _segments
        _progress = _segments * progress
        p = step1(_progress)
    end
    if 1 / _segments < progress ‚â§ 2 / _segments
        _progress = _segments * (progress - 1 / _segments)
        p = step2(_progress)
    end
    if 2 / _segments < progress ‚â§ 3 / _segments
        _progress = _segments * (progress - 2 / _segments)
        p = step3(_progress)
    end
    if 3 / _segments < progress ‚â§ 4 / _segments
        _progress = _segments * (progress - 3 / _segments)
        i = max(1, Int(floor(_progress * steps_number)))
        p = project(Œ≥‚ÇÇ[i][end])
        distance += 1e-2
    end
    
    global lookat = 0.9 * lookat + 0.1 * GLMakie.Vec3f(p...)
    up = GLMakie.Vec3f(0, 0, 1)
    azimuth = -œÄ / 2 + 0.3 * sin(2œÄ * progress) # set the view angle of the axis
    eyeposition = GLMakie.Vec3f(distance .* convert_to_cartesian([1; azimuth; œÄ / 7])...)
    GLMakie.update_cam!(lscene.scene, eyeposition, lookat, up)
end
