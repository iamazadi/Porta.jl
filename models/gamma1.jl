import FileIO
import DataFrames
import CSV
import GLMakie
using LinearAlgebra
using ModelingToolkit, DifferentialEquations, Latexify
using Porta


"""
    We begin with a path of Œª(s) in ‚ÑÇ. Œª: ‚Ñù ‚Üí ‚ÑÇ
    Then, u_‚àû maps this path of vectors in ‚ÑÇ to a Œ≥‚ÇÅ path of vectors in ‚ÑÇ¬≤. u_‚àû: ‚ÑÇ ‚Üí ‚ÑÇ¬≤
    Then, solving u‚Çì = Au from x = L to L' generates Œ≥‚ÇÇ paths in ‚ÑÇ¬≤. 
    The end points of which together form a Œ≥‚ÇÉ path in ‚ÑÇ¬≤.
    And these three types of path in ‚ÑÇ¬≤ project to paths on S¬≥ along which we integrate the connection form œâ to calculate the phase. P: ‚ÑÇ¬≤ ‚Üí S¬≥
    And of course all these paths may then be mapped onto S¬≤ by the Hopf map. œÄ: S¬≥ ‚Üí S¬≤ ‚äÇ ‚Ñù¬≥
    Rupert Way (2008)
"""


resolution = (1920, 1080)
segments = 120
frames_number = 240

r‚ÇÅ = 0.8
Œª‚ÇÅ = 1 + 0.2 * im # experiment 1
Œª‚ÇÇ = im # experiment 2
Œª‚ÇÉ = 2 + im # experiment 3
Œª‚ÇÑ = 0 # experiment 4
Œª‚ÇÖ = 1 # experiment 5
Œª‚ÇÜ = -im # experiment 6

r‚Çá = 0.5
Œª‚Çá = -im # experiment 7

r‚Çà = 0.8
Œª‚Çà = 2 - im # experiment 8

Œª‚ÇÄ = Œª‚ÇÇ
r = r‚ÇÅ

version = "r=$(r)_Œª‚ÇÄ=$(real(Œª‚ÇÄ))+ùëñ$(imag(Œª‚ÇÄ))"
modelname = "gamma1_$version"

getŒª(s) = Œª‚ÇÄ + r * exp(im * s)
getf(x) = (3 / 2) * sech(x / 2)^2
getA(x, s) = [0 1; getŒª(s) + 1 - 2getf(x) + 1 0]


"""
    getu‚àû(s)

Get the eigenvector corresponding to the most negative eigenvalue when x ‚Üí ‚àû.
u_‚àû: ‚ÑÇ ‚Üí ‚ÑÇ¬≤
"""
getu‚àû(s) = begin
    x = 100 # x ‚Üí ‚àû
    A‚àû = getA(x, s)
    Œº, Œæ = eigen(A‚àû)
    _, index = findmin(real.(Œº))
    Œæ[:, index]
end


L = 10.0
L‚Ä≤ = -L
C‚ÇÄ = [0 1; getŒª(L) + 1 - 2getf(L) 0]
A‚ÇÄ = real.(C‚ÇÄ)
B‚ÇÄ = imag.(C‚ÇÄ)
v‚ÇÄ = vec(normalize(Quaternion(getu‚àû(L))))

# Define our state variables: state(t) = initial condition
@variables t
@variables Œª·µ£(t)=real(getŒª(L))
@variables Œª·µ¢(t)=imag(getŒª(L))
@variables v(t)[1:4]=v‚ÇÄ
@variables Œ∏(t)=0
@variables f(t)=getf(L)
@variables A(t)[1:2,1:2]=A‚ÇÄ
@variables B(t)[1:2,1:2]=B‚ÇÄ
@variables Œ£(t)[1:4,1:4]=[A‚ÇÄ -B‚ÇÄ; B‚ÇÄ A‚ÇÄ]

# Define our parameters
@parameters I‚ÇÑ[1:4,1:4]=[1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 1] K‚ÇÉ[1:4,1:4]=K(3)

# Define our differential: takes the derivative with respect to `t`
D = Differential(t)

# Define the differential equations
eqs = [f ~ getf(t)
       Œª·µ£ ~ real(getŒª(t))
       Œª·µ¢ ~ imag(getŒª(t))
       A[1,1] ~ 0
       A[1,2] ~ 1
       A[2,1] ~ Œª·µ£ + 1 - 2f
       A[2,2] ~ 0
       B[1,1] ~ 0
       B[1,2] ~ 0
       B[2,1] ~ Œª·µ¢
       B[2,2] ~ 0
       Œ£[1,1] ~ A[1,1]
       Œ£[1,2] ~ A[1,2]
       Œ£[2,1] ~ A[2,1]
       Œ£[2,2] ~ A[2,2]
       Œ£[1,3] ~ -B[1,1]
       Œ£[1,4] ~ -B[1,2]
       Œ£[2,3] ~ -B[2,1]
       Œ£[2,4] ~ -B[2,2]
       Œ£[3,1] ~ B[1,1]
       Œ£[3,2] ~ B[1,2]
       Œ£[4,1] ~ B[2,1]
       Œ£[4,2] ~ B[2,2]
       Œ£[3,3] ~ A[1,1]
       Œ£[3,4] ~ A[1,2]
       Œ£[4,3] ~ A[2,1]
       Œ£[4,4] ~ A[2,2]
       D(v[1]) ~ ((I‚ÇÑ - v * v') * (Œ£ * v))[1]
       D(v[2]) ~ ((I‚ÇÑ - v * v') * (Œ£ * v))[2]
       D(v[3]) ~ ((I‚ÇÑ - v * v') * (Œ£ * v))[3]
       D(v[4]) ~ ((I‚ÇÑ - v * v') * (Œ£ * v))[4]
       D(Œ∏) ~ -dot(K‚ÇÉ * v, Œ£ * v)]

latexify(eqs)

# Bring these pieces together into an ODESystem with independent variable t
@named sys = ODESystem(eqs, t)

# Symbolically Simplify the System
simpsys = structural_simplify(sys)

# Convert from a symbolic to a numerical problem to simulate
tspan = (L, L‚Ä≤)
prob = ODEProblem(simpsys, [], tspan)

# Solve the ODE
sol = solve(prob)

makefigure() = GLMakie.Figure(resolution = resolution)
fig = GLMakie.with_theme(makefigure, GLMakie.theme_black())
pl = GLMakie.PointLight(GLMakie.Point3f(0), GLMakie.RGBf(20, 20, 20))
al = GLMakie.AmbientLight(GLMakie.RGBf(0.9, 0.9, 0.9))
lscene = GLMakie.LScene(fig[1, 1], show_axis=false, scenekw = (resolution = resolution, lights = [pl, al], backgroundcolor=:white, clear=true))

cam = GLMakie.camera(lscene.scene) # this is how to access the scenes camera
eyeposition = GLMakie.Vec3f(cam.eyeposition[]...)
lookat = GLMakie.Vec3f(0, 0, 0)
up = GLMakie.Vec3f(0, 0, 1)
# GLMakie.update_cam!(lscene.scene, eyeposition, lookat, up)

colorref = FileIO.load("data/basemap_color.png")
basemap_color = FileIO.load("data/basemap_mask1.png")


## Load the Natural Earth data

attributespath = "./data/gdp/geometry-attributes.csv"
nodespath = "./data/gdp/geometry-nodes.csv"

countries = loadcountries(attributespath, nodespath)

country_name1 = "United States of America"
country_name2 = "South Africa"
country_name3 = "Iran"
country_name4 = "Turkey"
country_name5 = "Australia"
country_name6 = "New Zealand"
country_nodes1 = Vector{Vector{Float64}}()
country_nodes2 = Vector{Vector{Float64}}()
country_nodes3 = Vector{Vector{Float64}}()
country_nodes4 = Vector{Vector{Float64}}()
country_nodes5 = Vector{Vector{Float64}}()
country_nodes6 = Vector{Vector{Float64}}()
for i in 1:length(countries["name"])
    if countries["name"][i] == country_name1
        country_nodes1 = countries["nodes"][i]
        country_nodes1 = convert(Vector{Vector{Float64}}, country_nodes1)
        println(typeof(country_nodes1))
        println(country_name1)
    end
    if countries["name"][i] == country_name2
        country_nodes2 = countries["nodes"][i]
        println(country_name2)
    end
    if countries["name"][i] == country_name3
        country_nodes3 = countries["nodes"][i]
        println(country_name3)
    end
    if countries["name"][i] == country_name4
        country_nodes4 = countries["nodes"][i]
        println(country_name4)
    end
    if countries["name"][i] == country_name5
        country_nodes5 = countries["nodes"][i]
        println(country_name5)
    end
    if countries["name"][i] == country_name6
        country_nodes6 = countries["nodes"][i]
        println(country_name6)
    end
end

Œ± = 0.1
color1 = getcolor(country_nodes1, colorref, Œ±)
color2 = getcolor(country_nodes2, colorref, Œ±)
color3 = getcolor(country_nodes3, colorref, Œ±)
color4 = getcolor(country_nodes4, colorref, Œ±)
color5 = getcolor(country_nodes5, colorref, Œ±)
color6 = getcolor(country_nodes6, colorref, Œ±)
w1 = [œÑmap(country_nodes1[i]) for i in eachindex(country_nodes1)]
w2 = [œÑmap(country_nodes2[i]) for i in eachindex(country_nodes2)]
w3 = [œÑmap(country_nodes3[i]) for i in eachindex(country_nodes3)]
w4 = [œÑmap(country_nodes4[i]) for i in eachindex(country_nodes4)]
w5 = [œÑmap(country_nodes5[i]) for i in eachindex(country_nodes5)]
w6 = [œÑmap(country_nodes6[i]) for i in eachindex(country_nodes6)]
whirl1 = Whirl(lscene, w1, [0.0 for i in 1:length(w1)], [2œÄ for i in 1:length(w1)], segments, color1, transparency = true)
whirl2 = Whirl(lscene, w2, [0.0 for i in 1:length(w2)], [2œÄ for i in 1:length(w2)], segments, color2, transparency = true)
whirl3 = Whirl(lscene, w3, [0.0 for i in 1:length(w3)], [2œÄ for i in 1:length(w3)], segments, color3, transparency = true)
whirl4 = Whirl(lscene, w4, [0.0 for i in 1:length(w4)], [2œÄ for i in 1:length(w4)], segments, color4, transparency = true)
whirl5 = Whirl(lscene, w5, [0.0 for i in 1:length(w5)], [2œÄ for i in 1:length(w5)], segments, color5, transparency = true)
whirl6 = Whirl(lscene, w6, [0.0 for i in 1:length(w6)], [2œÄ for i in 1:length(w6)], segments, color6, transparency = true)
frame1 = Frame(lscene, x -> G(0, œÑmap(x)), segments, basemap_color, transparency = true)
frame2 = Frame(lscene, x -> G(0, œÑmap(x)), segments, basemap_color, transparency = true)


samples = length(sol[v])
Œ≥‚ÇÅ = Vector{Quaternion}(undef, samples)
phases = Vector{Float64}(undef, samples)
path_x = Vector{Float64}(undef, samples)
path_y = Vector{Float64}(undef, samples)
path_z = Vector{Float64}(undef, samples)
points = GLMakie.Observable(GLMakie.Point3f[]) # Signal that can be used to update plots efficiently
colors = GLMakie.Observable(Int[])
lines = GLMakie.lines!(lscene, points, linewidth = 3.0, color = colors, colormap = :jet, transparency = true)
for i in 1:samples
    Œ≥‚ÇÅ[i] = Quaternion(sol[v][i])
    p = project(Œ≥‚ÇÅ[i])
    path_x[i] = p[1]
    path_y[i] = p[2]
    path_z[i] = p[3]
    phases[i] = sol[Œ∏][i]
end


_hopfmap(q) = begin
    a, b, c, d = vec(q)
    z‚ÇÅ = a + c * im
    z‚ÇÇ = b + d * im
    cartesian = convert_to_cartesian(z‚ÇÇ / z‚ÇÅ)
    geographic = convert_to_geographic(cartesian)
    r, œï, _Œ∏ = vec(geographic)
    convert_to_cartesian([r; -œï; _Œ∏])
end


basepoints = map(x -> project(œÑmap(_hopfmap(x))), Œ≥‚ÇÅ)
px = [basepoints[i][1] for i in 1:samples] # œÄ: S¬≥ ‚Üí S¬≤ ‚äÇ ‚Ñù¬≥
py = [basepoints[i][2] for i in 1:samples]
pz = [basepoints[i][3] for i in 1:samples]
rainbowcolors = [GLMakie.RGBAf(convert_hsvtorgb([i / samples * 360; 1; 1])..., 0.9) for i in 1:samples]


function step!(i, frame)
    push!(points[], GLMakie.Point3f(path_x[i], path_y[i], path_z[i]))
    push!(colors[], frame)
end


GLMakie.record(fig, joinpath("gallery", "$modelname.mp4"), 1:frames_number) do frame
    println("Frame: $frame")
    progress = frame / frames_number
    rgb = convert_hsvtorgb([progress * 360; 1; 1])
    rgb‚Ä≤ = convert_hsvtorgb([progress * 360; 0.5; 0.5])
    i = max(1, Int(floor(progress * samples)))
    step!(i, frame) # update arrays inplace
    
    Œ± = 0.25
    
    GLMakie.meshscatter!([px[i]], [py[i]], [pz[i]], markersize = 0.015, color = rainbowcolors[i], transparency = true)

    _basepoints = map(x -> project(G(phases[i], œÑmap(_hopfmap(x)))), Œ≥‚ÇÅ)
    _px = [_basepoints[j][1] for j in 1:i] # œÄ: S¬≥ ‚Üí S¬≤ ‚äÇ ‚Ñù¬≥
    _py = [_basepoints[j][2] for j in 1:i]
    _pz = [_basepoints[j][3] for j in 1:i]
    GLMakie.meshscatter!(_px, _py, _pz, markersize = 0.01, color = rainbowcolors[1:i], transparency = true)
    
    p = project(Œ≥‚ÇÅ[i])
    tail = [GLMakie.Point3f(p...) for _ in 1:3]
    head = [GLMakie.Point3f(project(K(3) * Œ≥‚ÇÅ[i])...), GLMakie.Point3f(project(K(1) * Œ≥‚ÇÅ[i])...) * 0.25, GLMakie.Point3f(project(K(2) * Œ≥‚ÇÅ[i])...) * 0.25]
    linecolor = [GLMakie.RGBAf(rgb..., Œ±), GLMakie.RGBAf(rgb‚Ä≤..., Œ± / 2), GLMakie.RGBAf(rgb‚Ä≤..., Œ± / 2)]
    arrowcolor = [GLMakie.RGBAf(rgb..., Œ±), GLMakie.RGBAf(rgb‚Ä≤..., Œ± / 2), GLMakie.RGBAf(rgb‚Ä≤..., Œ± / 2)]
    GLMakie.arrows!(lscene, tail, head, fxaa=true, linecolor = linecolor, arrowcolor = arrowcolor, linewidth = 0.01, arrowsize = GLMakie.Vec3f(0.025, 0.025, 0.05), transparency = true)
    GLMakie.meshscatter!([p[1]], [p[2]], [p[3]], markersize = 0.01, color = GLMakie.RGBAf(rgb..., Œ±), transparency = true)
    update!(frame1, x -> G(phases[i], œÑmap(x)))

    # hor_xs = LinRange(0, 10, 100)
    # hor_ys = LinRange(0, 15, 100)
    # hor_zs = [cos(x) * sin(y) for x in xs, y in ys]

    # surface(xs, ys, zs, axis=(type=Axis3,))

    lines.colorrange = (0, frame) # update plot attribute directly
    notify(points); notify(colors) # tell points and colors that their value has been updated
    global lookat = 0.99 * lookat + 0.01 * GLMakie.Vec3f(p...)
    up = GLMakie.Vec3f(0, 0, 1)
    azimuth = -œÄ / 2 + 0.3 * sin(2œÄ * progress) # set the view angle of the axis
    eyeposition = GLMakie.Vec3f(œÄ / 2 .* convert_to_cartesian([1; azimuth; œÄ / 8])...)
    GLMakie.update_cam!(lscene.scene, eyeposition, lookat, up)
end
