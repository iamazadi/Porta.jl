<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reaction Wheel Unicycle · Porta.jl</title><meta name="title" content="Reaction Wheel Unicycle · Porta.jl"/><meta property="og:title" content="Reaction Wheel Unicycle · Porta.jl"/><meta property="twitter:title" content="Reaction Wheel Unicycle · Porta.jl"/><meta name="description" content="How the reaction wheel unicycle works."/><meta property="og:description" content="How the reaction wheel unicycle works."/><meta property="twitter:description" content="How the reaction wheel unicycle works."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.gif" alt="Porta.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="Porta.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Porta.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="hopffibration.html">Hopf Fibration</a></li><li><a class="tocitem" href="newsreport.html">News Report</a></li><li class="is-active"><a class="tocitem" href="reactionwheelunicycle.html">Reaction Wheel Unicycle</a><ul class="internal"><li><a class="tocitem" href="#Introducing-Reinforcement-Learning-and-Feedback-Control"><span>Introducing Reinforcement Learning and Feedback Control</span></a></li><li><a class="tocitem" href="#Natural-Decision-Methods"><span>Natural Decision Methods</span></a></li><li><a class="tocitem" href="#An-Optimal-Adaptive-Controller"><span>An Optimal Adaptive Controller</span></a></li><li><a class="tocitem" href="#The-Z-Euler-Angle-Is-Not-Observable"><span>The Z-Euler Angle Is Not Observable</span></a></li><li><a class="tocitem" href="#Stepping-Through-the-Implementation"><span>Stepping Through the Implementation</span></a></li><li><a class="tocitem" href="#The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters"><span>The Convergence of Selected Algebraic Riccati Equation Solution Parameters</span></a></li><li><a class="tocitem" href="#The-Controllability-of-the-Z-Euler-Angle"><span>The Controllability of the Z-Euler Angle</span></a></li><li><a class="tocitem" href="#Nonholonomic-Motion-Planning"><span>Nonholonomic Motion Planning</span></a></li><li><a class="tocitem" href="#Steering-Using-Sinusoids"><span>Steering Using Sinusoids</span></a></li><li><a class="tocitem" href="#Steering-Second-Order-Canonical-Systems"><span>Steering Second-Order Canonical Systems</span></a></li><li><a class="tocitem" href="#Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion"><span>Attitude Control of A Space Platform / Manipulator System Using Internal Motion</span></a></li><li><a class="tocitem" href="#Porta"><span>Porta</span></a></li><li><a class="tocitem" href="#Fiber-Optic-Gyroscopes"><span>Fiber Optic Gyroscopes</span></a></li><li><a class="tocitem" href="#Resources"><span>Resources</span></a></li></ul></li><li><a class="tocitem" href="multivariablecalculus.html">Multivariable Calculus</a></li><li><a class="tocitem" href="maxwellfield_persian.html">The Maxwell Field (Persian)</a></li><li><a class="tocitem" href="reactionwheelunicycle_persian.html">The Unicycle (Persian)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reactionwheelunicycle.html">Reaction Wheel Unicycle</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reactionwheelunicycle.html">Reaction Wheel Unicycle</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/iamazadi/Porta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/iamazadi/Porta.jl/blob/master/docs/src/reactionwheelunicycle.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="How-the-Reaction-Wheel-Unicycle-Works"><a class="docs-heading-anchor" href="#How-the-Reaction-Wheel-Unicycle-Works">How the Reaction Wheel Unicycle Works</a><a id="How-the-Reaction-Wheel-Unicycle-Works-1"></a><a class="docs-heading-anchor-permalink" href="#How-the-Reaction-Wheel-Unicycle-Works" title="Permalink"></a></h1><p>This is a model of a unicycle with two symmetrically attached rotors. One of the reasons the matrix of inertia is not trivial is that the rotors’ axes of rotation do not intersect at a point. The constraint on the system is conservation of angular momentum. The angular velocity of the body is related to the rotor velocities. That relation gives rise to a differential equation in the rotation group Special Orthogonal (3) for the robot’s body. Using the Euler parameters of SO(3) we obtain a local coordinate description of the differential equation, in terms of the roll, pitch and yaw angles. The robot can be repositioned by controlling the rotor velocities. The Linear Quadratic Regulator regulates the roll and pitch angles by a choice of a suitable input.</p><h2 id="Introducing-Reinforcement-Learning-and-Feedback-Control"><a class="docs-heading-anchor" href="#Introducing-Reinforcement-Learning-and-Feedback-Control">Introducing Reinforcement Learning and Feedback Control</a><a id="Introducing-Reinforcement-Learning-and-Feedback-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Introducing-Reinforcement-Learning-and-Feedback-Control" title="Permalink"></a></h2><h2 id="Natural-Decision-Methods"><a class="docs-heading-anchor" href="#Natural-Decision-Methods">Natural Decision Methods</a><a id="Natural-Decision-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-Decision-Methods" title="Permalink"></a></h2><h2 id="An-Optimal-Adaptive-Controller"><a class="docs-heading-anchor" href="#An-Optimal-Adaptive-Controller">An Optimal Adaptive Controller</a><a id="An-Optimal-Adaptive-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#An-Optimal-Adaptive-Controller" title="Permalink"></a></h2><p>System states in real time. Even though the matrix of inertia (among other physical parameters) is unknown, the adaptive controller based on value iteration keeps the states stable and regulates them to zero. The index <code>k</code> denotes value iteration whereas the index <code>j</code> counts the number of policy updates.</p><h2 id="The-Z-Euler-Angle-Is-Not-Observable"><a class="docs-heading-anchor" href="#The-Z-Euler-Angle-Is-Not-Observable">The Z-Euler Angle Is Not Observable</a><a id="The-Z-Euler-Angle-Is-Not-Observable-1"></a><a class="docs-heading-anchor-permalink" href="#The-Z-Euler-Angle-Is-Not-Observable" title="Permalink"></a></h2><h2 id="Stepping-Through-the-Implementation"><a class="docs-heading-anchor" href="#Stepping-Through-the-Implementation">Stepping Through the Implementation</a><a id="Stepping-Through-the-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Stepping-Through-the-Implementation" title="Permalink"></a></h2><p>In this section, we step through the implementation of the robot&#39;s controller in the order of execution. The controller is implemented in the C programming language. It runs on a STM32F401RE mictocontroller, which is clocked at 84 MHz. Here. we focus on the part of the code that runs in the main loop, which is a <code>while</code> loop in the main function of the program.</p><ul><li></li></ul><p>The microcontroller is built around a Cortex-M4 with Floating Point Unit (FPU) core, which contains hardware extensions for debugging features. The debug extensions allow the core to be stopped either on a given instruction fetch (breakpoint), or on data access (watchpoint). When stopped, the core&#39;s internal state and the system&#39;s external state may be examined. Once examination is complete, the core and the system may be restored and program execution resumed.</p><p><img src="assets/reactionwheelunicycle/schematics/nucleof401re.jpeg" alt="nucleof401re"/></p><p>The ARM Cortex-M4 with FPU core provides integrated on-chip debug support. One of the debug features is called Data Watchpoint Trigger (DWT). The DWT unit  provides a means to give the number of clock cycles. The DWT register <code>CYCCNT</code> counts the number of clock cycles. The period of a control cycle is required in the application for integrating the gyroscopic angle rates. If we count the number of clocks twice: one time before the loop begins and one time after the loop ends, then we can find the time period that it takes to complete a control loop. In the beginning, we count the number of clocks by assigning the register value to a variable called <code>t1</code>.</p><pre><code class="language-c hljs">t1 = DWT-&gt;CYCCNT;</code></pre><ul><li></li></ul><p>There are two fuse bits on the robot for configuration without flashing a program. The first one is connected to the port C of the general purpose input / output, pin 0. The fuse bit is active whenever the connected pin is grounded. The fuse bit deactivates the linear quadratic regulator by clearing the <code>active</code> field as a flag in the model structure. Even though the status of the fuse bit 0 is necessary to activate the model, it is not a sufficient condition. The user must connect the fuse bit and also push a blue push button once on the robot for activating the model. The push button is the same blue button that is found on the NUCLEOF401RE board. These two conditions are chained together for safety reasons. If the model is not active, then the robot must stop moving. Therefore, the output of the model must be set to zero as well in order to override the last action of the model. But, the speed of a direct current motor is directly proportional to the amplitude of the enable signals of the motor driver, L293D. In the peripherals of the microcontroller, two channels of Timer 2 generate the driver enable signals: EN1,2 and EN3,4. If the model is not active, then the duty cycle of the Pulse Width Modulation (PWM) of each timer channel is set to zero for safety. </p><p><img src="assets/reactionwheelunicycle/schematics/buttonsandlights.jpeg" alt="buttonsandlights"/></p><pre><code class="language-c hljs">if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_0) == 0)
{
  if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == 0)
  {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
    model.active = 1;
  }
}
else
{
  model.active = 0;
  model.reactionPWM = 0.0;
  model.rollingPWM = 0.0;
  TIM2-&gt;CCR1 = 0;
  TIM2-&gt;CCR2 = 0;
}</code></pre><ul><li></li></ul><p>When the reaction wheel unicycle falls over, the roll and pitch angles of the chassis with respect to the pivot point exeed ten degrees. The geared motors produce high torques in stall mode after their failure to prevent the fall from happening. It makes sense to disable the actuators to save energy resources and reduce physical shocks to the motor gearboxes. The lower and upper bounds on the roll and pitch angles are combined using the logical &quot;or&quot; operator <code>||</code> with the episode counter so that the model stops running after the maximum number of interactions with the environment, the total steps in an episode. A fall or a certain number of interactions, whichever comes first, causes the model to deactivate. In order to make the robot live longer and consume less power, three conditions must be met, or else the model is deactivated and the green light on the NUCLEOF401RE turns on to signify that the controller is no longer active. The user has four options in whenever the green LED lights up:</p><ol><li><p>Pick the robot up and make it stand upright, before pushing the blue push button to run again.</p></li><li><p>Switch the power button on the chassis to condition zero, in order to power off the robot.</p></li><li><p>Connect to the robot WiFi network and execute the following command in the terminal for printing the logs. Print uart6 serial messages by executing: <code>nc 192.168.4.1 10000</code></p></li><li><p>Activate the Porta.jl environment in a Julia REPL and run the linked script for visualizing the logs: <a href="https://github.com/iamazadi/Porta.jl/blob/master/models/unicycle.jl">Unicycle</a></p></li></ol><p>The controller stops spinning and stays that way, unless one of the above are performed by the user.</p><pre><code class="language-c hljs">if (fabs(model.imu1.roll) &gt; roll_safety_angle || fabs(model.imu1.pitch) &gt; pitch_safety_angle || model.k &gt; max_episode_length)
{
  model.active = 0;
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
}</code></pre><ul><li></li></ul><p>If the model is set to be active, then the controller takes one step forward. The function <code>stepForward</code> takes as argument a pointer to the model, mainly because two of its fields require persistent memory: the filter matrix <code>W_n</code> and the inverse autocorrelation matrix <code>P_n</code>. But also partly because the sensory fields among others are updated inside the function. The actual side effect of this function call is the action of the feedback policy, which changes the angular velocity of the motors.</p><pre><code class="language-c hljs">if (model.active == 1)
{
  stepForward(&amp;model);
}</code></pre><ul><li></li></ul><p>In case the model is not active, a block of code runs instead of the <code>stepForward</code> function, in order to make sure the motors stop moving, and to update sensors for development purposes. First, the duty cycles are set to zero, both in the model struct fields and in the respective channels of Timer 2. Second, the driver inputs are all cleared to make a breaking condition according to the driver&#39;s data sheet. Third, the encoder of the reaction wheel is updated by calling the <code>encodeWheel</code> function, supplying a pointer to the encoder&#39;s instantiation and the value of the counter register <code>CNT</code> of Timer 3. Timer 3 is configured with two cannels A nd B for reading the absolute position of the wheel. What Timer 3 counts in the &quot;encoder mode&quot; is the angular position of the reaction wheel. Then, the <code>encodeWheel</code> function transforms the angular position to the angular velocity for the linear quadratic regulator model. The rolling wheel&#39;s encoder works in the same way, except Timer 4 is used. Next, the rate of electric current in the coils of the motors is measured by calling the <code>senseCurrent</code> function with pointers to the current sensor struct of the motors.</p><p>Finally, the Inertial Measurement Unit (IMU) is updated by calling the <code>updateIMU</code> function with the pointer to the model struct. There are two IMUs on the robot for estimating tilt at the pivot point rather than the point where the IMUs are located. The essential feature of the <code>updateIMU</code> function is the ability to calculate the roll and pitch angles using the static acceleration of gravity, discarding the dynamical part of acceleration beforehand. The quality of tilt estimation depends on three features:</p><ol><li><p>The calculation is done for the pivot point.</p></li><li><p>The calculation does not consider dynamical accelerations of the robot.</p></li><li><p>The tilt estimation given the accelerometers is enhanced by fusing it with gyroscopic measurements.</p></li></ol><pre><code class="language-c hljs">else
{
  model.reactionPWM = 0.0;
  model.rollingPWM = 0.0;
  TIM2-&gt;CCR1 = 0;
  TIM2-&gt;CCR2 = 0;
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);
  encodeWheel(&amp;model.reactionEncoder, TIM3-&gt;CNT);
  encodeWheel(&amp;model.rollingEncoder, TIM4-&gt;CNT);
  senseCurrent(&amp;(model.reactionCurrentSensor), &amp;(model.rollingCurrentSensor));
  updateIMU(&amp;model);
}</code></pre><ul><li></li></ul><p>An episode is defined as one or more sequential interactions with the environment. An episode is finished once the robot falls over or when the control policy is updated. The field <code>k</code> of the model counts the number of environment interactions in an episode. Since the <code>stepForward</code> function is essentially a Recursive Least Squares (RLS) algorithm, it will make the filter matrix <code>W_n</code> and the inverse autocorrelation matrix <code>P_n</code> converge after a finite number of runs. The exact number of runs for the RLS to converge is not constant, but we can assume that it is small when the robot approaches a state in which opposing angular momenta are balanced. Therefore, by counting the number of <code>stepForward</code> function calls we can insert control policy updates periodically. The function <code>updateControlPolicy</code> is given a pointer to the model object and its side effect is an update to the feedback policy matrix <code>K_j</code>. The index of the feeback policy matrix is different from the index of the filter matrix <code>W_n</code> and the inverse autocorrelation matrix <code>P_n</code>. A second counter variable <code>j</code> is incremented every time the control policy is updated, whereas the variable <code>k</code> counts the number of calls to the <code>stepForward</code> function. However, if the update frequency is higher than one control cycle then the variable <code>j</code> counts at a slower rate than the variable <code>k</code>. As the model learns from experience online and in real time, the variable <code>updatePolicyPeriod</code> determines how much experience is accumulated before a policy update. Experimentally, 10 value iterations per policy update is the optimal ratio.</p><pre><code class="language-c hljs">if (model.k % updatePolicyPeriod == 0)
{
  updateControlPolicy(&amp;model);
}</code></pre><ul><li></li></ul><p>In order to monitor the controller and debug issues we write the logs periodically to the standard input / output console. The variable <code>log_counter</code> is incremented by one every control cycle. Then, the log counter is compared to the constnt <code>LOG_CYCLE</code> for finding out if a cycle should be logged. But it is not a sufficient condition for logging because a second fuse bit is also rquired for permission to log. The second fuse bit is connected to the port C of the general purpose input / output, pin 1. Whenever the fuse bit pin is grounded it is activated. Once the fuse bit is active, the transmission flag <code>transmit</code> is set at the appropriate control cycle count. The reason for <code>LOG_CYCLE</code> is to limit the total number of logs per second, as the Micro-Controller Unit (MCU) is too fast for a continuous report. And the second fuse bit is there to turn off logging for saving time, as log transmissions takes time away from the control processes. So by using the logical &quot;and&quot; operator <code>&amp;&amp;</code> we can combine the logging cycle condition with the logging fuse bit, in order to regulate the frequnecy of transmissions.</p><pre><code class="language-c hljs">log_counter++;
if (log_counter &gt; LOG_CYCLE &amp;&amp; HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_1) == 0)
{
  transmit = 1;
}</code></pre><ul><li></li></ul><p>If the <code>transmit</code> variable is equal to one, then the log counter is cleard along with the <code>transmit</code> variable before transmission. The function <code>sprintf</code> is called with a message buffer <code>MSG</code> and a formatted character string to populate the buffer with numbers. A log message can be anything, but for finding the matrix of known parameters in tilt estimation, the accelerometrs data must be included. After the message is composed, it is given as an argument to the function <code>HAL_UART_Transmit</code>, which stands for: Hardware Abstraction Layer, Universal Asynchronous Receiver / Transmitter, Transmit. The function also requires a pointer to <code>uart6</code>, which is a micro-controller peripheral for serial communication, and the size of the message buffer, along with a time out delay. Printing and transmitting the log finishes the main control loop. The console on the other side of tranmission receives a line like this: <code>AX1: 0.34, AY1: 0.03, AZ1: 0.95, | AX2: 0.34, AY2: 0.02, AZ2: 0.94, | roll: -0.34, pitch: -0.03, | encT: 0.00, encB: 0.00, | k: 1, j: 1, | x0: 0.00, x1: 0.00, x2: 0.00, x3: 0.00, x4: 0.00, x5: 0.00, x6: 0.00, x7: 0.00, x8: 0.00, x9: 0.00, x10: 0.00, x11: 0.00, | P0: 0.12, P1: 1.00, P2: 1.00, P3: 1.00, P4: 1.00, P5: 1.00, P6: 1.00, P7: 1.00, P8: 1.00, P9: 1.00, P10: 1.00, P11: 1.00, dt: 0.001847</code>.</p><p>You can visualize this example message using the <a href="https://github.com/iamazadi/Porta.jl/blob/master/models/unicycle.jl">Unicycle</a> script. The example includes: the tri-axis acceleromer measurements of IMU 1 and IMU 2, the roll and pitch angles after sensor fusion, the absolute position of both encoders, and the diagonal entries of the inverse auto-correlation matrix <code>P_n</code>. Different messages can be composed for different use cases, for example printing raw sensor readings for calibrating the zero point and the scale of the accelerometers axes.</p><pre><code class="language-c hljs">if (transmit == 1)
{
  transmit = 0;
  log_counter = 0;
  sprintf(MSG,
          &quot;AX1: %0.2f, AY1: %0.2f, AZ1: %0.2f, | AX2: %0.2f, AY2: %0.2f, AZ2: %0.2f, | roll: %0.2f, pitch: %0.2f, | encT: %0.2f, encB: %0.2f, | k: %f, j: %f, | x0: %0.2f, x1: %0.2f, x2: %0.2f, x3: %0.2f, x4: %0.2f, x5: %0.2f, x6: %0.2f, x7: %0.2f, x8: %0.2f, x9: %0.2f, x10: %0.2f, x11: %0.2f, | P0: %0.2f, P1: %0.2f, P2: %0.2f, P3: %0.2f, P4: %0.2f, P5: %0.2f, P6: %0.2f, P7: %0.2f, P8: %0.2f, P9: %0.2f, P10: %0.2f, P11: %0.2f, dt: %0.6f\r\n&quot;,
          model.imu1.accX, model.imu1.accY, model.imu1.accZ, model.imu2.accX, model.imu2.accY, model.imu2.accZ, model.imu1.roll, model.imu1.pitch, model.reactionEncoder.radianAngle, model.rollingEncoder.radianAngle, (float) model.k, (float) model.j, model.dataset.x0, model.dataset.x1, model.dataset.x2, model.dataset.x3, model.dataset.x4, model.dataset.x5, model.dataset.x6, model.dataset.x7, model.dataset.x8, model.dataset.x9, model.dataset.x10, model.dataset.x11, getIndex(model.P_n, 0, 0), getIndex(model.P_n, 1, 1), getIndex(model.P_n, 2, 2), getIndex(model.P_n, 3, 3), getIndex(model.P_n, 4, 4), getIndex(model.P_n, 5, 5), getIndex(model.P_n, 6, 6), getIndex(model.P_n, 7, 7), getIndex(model.P_n, 8, 8), getIndex(model.P_n, 9, 9), getIndex(model.P_n, 10, 10), getIndex(model.P_n, 11, 11), dt);
  HAL_UART_Transmit(&amp;huart6, MSG, sizeof(MSG), 1000);
}
// Rinse and repeat :)</code></pre><p>In order to enable the function <code>sprintf</code> to use floating point numbers, do the following steps:</p><ol><li>Open the file <code>gcc-arm-none-eabi.cmake</code> that is created by CubeMX.</li><li>Add the option <code>-u _printf_float</code> to <code>CMAKE_C_FLAGS</code>.</li></ol><p><img src="assets/reactionwheelunicycle/schematics/wifimodule.jpeg" alt="wifimodule"/></p><p>Set the baudrate of <code>uart6</code> to 921600, for the wifi module HC-25. The HC-25 module settings are on the IP address <code>192.168.4.1</code> as a web page. Here is the checklist to set up a new module:</p><ol><li>The password is not set for new modules. So just login without a password to access the settings page.</li><li>Set a username and password for the robot&#39;s access point.</li><li>Set the <em>WiFi Mode</em> to <strong>AP</strong> for Access Point.</li><li>Change the port number from <em>8080</em> to <em>10000</em>.</li><li>Set the <em>Baud Rate</em> parameter to 921600 Bits/s.</li></ol><ul><li></li></ul><p>At the end of the control loop, where the model has taken one step forward and possibly the control policy has been updated, it is time to count the number of the processor&#39;s clock cycles for a second time for measuring delta <code>t</code>. At this point, by assigning the value of the DWT counter register to the variable <code>t2</code> we can know how many cycles are there between <code>t1</code> and <code>t2</code>. Having calculated the temporal difference between the start of the main loop and its end in terms of the processor&#39;s cycles, we then divide the difference by the number of Central Processing Unit (CPU) clock cycles per second for finding the period of the control cycle in the unit of seconds. The field <code>dt</code> of the model struct stores the control period for intermediate physical calculations. The control period is ususally 2 to 5 milliseconds on a NUCLEOF401RE, which clocks at 84 Mhz.</p><pre><code class="language-c hljs">t2 = DWT-&gt;CYCCNT;
diff = t2 - t1;
dt = (float)diff / CPU_CLOCK;
model.dt = dt;</code></pre><ul><li></li></ul><p>The function <code>stepForward</code> identifies the Q function using RLS with the given pointer to the <code>model</code>. The algorithm updates the Q function at each step. The main side effect of the function is an interaction with the environment, which consists of reading the sensors and changing the speed of rotation of the motors. In the end, the filter matrix <code>W_n</code> and the inverse auto-correlation matrix <code>P_n</code> are updated.</p><pre><code class="language-c hljs">void stepForward(LinearQuadraticRegulator *model)</code></pre><ul><li></li></ul><p>The vector <code>x_k</code> is initialized as an array of element type <code>float</code> with the model data set. The data set (xₖ, uₖ, xₖ₊₁, uₖ₊₁) contains data from two consecutive time steps <code>k</code> and <code>k + 1</code>. The number of dimensions of the <code>x_k</code> vector is equal to n = 10, storing the system state at time <code>k</code>. Each element of the state vector xₖ ∈ ℝⁿ has a name that represents a physical quantity. The order of the feature names are the same in both time indices: the roll angle, the roll angular velocity, the roll angular acceleration, the pitch angle, the pitch angular velocity, the pitch angular acceleration, the angular velocity of the reaction wheel, the angular velocity of the rolling wheel, the electric current velocity of the reaction motor, and the electric current velocity of the rolling motor.</p><pre><code class="language-c hljs">x_k[0] = model-&gt;dataset.x0;
x_k[1] = model-&gt;dataset.x1;
x_k[2] = model-&gt;dataset.x2;
x_k[3] = model-&gt;dataset.x3;
x_k[4] = model-&gt;dataset.x4;
x_k[5] = model-&gt;dataset.x5;
x_k[6] = model-&gt;dataset.x6;
x_k[7] = model-&gt;dataset.x7;
x_k[8] = model-&gt;dataset.x8;
x_k[9] = model-&gt;dataset.x9;</code></pre><ul><li></li></ul><p>After initializing the state buffer <code>x_k</code>, another buffer is initialized with the feedback policy matrix <code>K_j</code>. The matrix Kⱼ ∈ ℝᵐˣⁿ has m = 2 rows since there are two inputs and it has n = 10 columns as there are ten states. The only reason for initializing <code>K_j</code> in the <code>stepForward</code> function is to execute a feedback policy action right before performing the measurements of the next time step <code>k + 1</code>. So the matrix and its index <code>j</code> stay constant throughout this function call.</p><pre><code class="language-c hljs">K_j[0][0] = model-&gt;K_j.x00;
K_j[0][1] = model-&gt;K_j.x01;
K_j[0][2] = model-&gt;K_j.x02;
K_j[0][3] = model-&gt;K_j.x03;
K_j[0][4] = model-&gt;K_j.x04;
K_j[0][5] = model-&gt;K_j.x05;
K_j[0][6] = model-&gt;K_j.x06;
K_j[0][7] = model-&gt;K_j.x07;
K_j[0][8] = model-&gt;K_j.x08;
K_j[0][9] = model-&gt;K_j.x09;
K_j[1][0] = model-&gt;K_j.x10;
K_j[1][1] = model-&gt;K_j.x11;
K_j[1][2] = model-&gt;K_j.x12;
K_j[1][3] = model-&gt;K_j.x13;
K_j[1][4] = model-&gt;K_j.x14;
K_j[1][5] = model-&gt;K_j.x15;
K_j[1][6] = model-&gt;K_j.x16;
K_j[1][7] = model-&gt;K_j.x17;
K_j[1][8] = model-&gt;K_j.x18;
K_j[1][9] = model-&gt;K_j.x19;</code></pre><ul><li></li></ul><p>The inputs of the system are stored in a vector uₖ ∈ ℝᵐ, which is the result of a matrix-vector product. The input is a function of the current system state at time step <code>k</code>. The feedback policy matrix <code>K_j</code> times the state vector <code>x_k</code> equals the negative of the input <code>u_k</code>. It is called the input because the product produces m = 2 floating point numbers that are used to modulate the duty cycle of the motors.</p><ul><li></li></ul><pre><code class="language-c hljs">u_k[0] = 0.0;
u_k[1] = 0.0;
for (int i = 0; i &lt; model-&gt;m; i++)
{
  for (int j = 0; j &lt; model-&gt;n; j++)
  {
    u_k[i] += -K_j[i][j] * x_k[j];
  }
}</code></pre><ul><li></li></ul><p>The data set (xₖ, uₖ, xₖ₊₁, uₖ₊₁) of the Linear Quadratic Regulator (LQR) model directly sums up the ststem state <code>x_k</code> and the system input <code>u_k</code>. The roll and pitch angles and their derivatives with respect to time are divided by π in order to normalize the anglular values. The velocities of the wheels and the current rates of the motors are also normalized to be in the closed interval [-1, 1]. But those normalizations are encapsulated inside the <code>encodeWheel</code> and <code>senseCurrent</code> functions respectively. Since the RLS algorithm is an iterative computation, normalizing data makes the numerical results stable by limiting the absolute value of the elements of the matrices <code>W_n</code> and <code>P_n</code>. The first half of the data set pertains to the time step <code>k</code>, which occurs before the action is executed. The second half of the data set is assiged after the action has taken place.</p><p><span>$(x_k, u_k, x_{k + 1}, u_{k + 1})$</span></p><pre><code class="language-c hljs">model-&gt;dataset.x0 = model-&gt;imu1.roll / M_PI;
model-&gt;dataset.x1 = model-&gt;imu1.roll_velocity / M_PI;
model-&gt;dataset.x2 = model-&gt;imu1.roll_acceleration / M_PI;
model-&gt;dataset.x3 = model-&gt;imu1.pitch / M_PI;
model-&gt;dataset.x4 = model-&gt;imu1.pitch_velocity / M_PI;
model-&gt;dataset.x5 = model-&gt;imu1.pitch_acceleration / M_PI;
model-&gt;dataset.x6 = model-&gt;reactionEncoder.velocity;
model-&gt;dataset.x7 = model-&gt;rollingEncoder.velocity;
model-&gt;dataset.x8 = model-&gt;reactionCurrentSensor.currentVelocity;
model-&gt;dataset.x9 = model-&gt;rollingCurrentSensor.currentVelocity;
model-&gt;dataset.x10 = u_k[0];
model-&gt;dataset.x11 = u_k[1];</code></pre><ul><li></li></ul><p>The LQR inputs are bidirectional and analog. The LQR regulates the roll and pitch angles by a choice of a suitable input. There are four digital input pins: <strong>1A</strong>, <strong>2A</strong>, <strong>3A</strong>, <strong>4A</strong>, and a pair of analog enable pins: <strong>1,2En</strong> and <strong>3,4EN</strong>. The enable pins control the speeds of rotation with a 16-bit resolution, whereas the logical input pins: <strong>1A</strong>, <strong>2A</strong>, <strong>3A</strong> and <strong>4A</strong> control the direction of rotation. A motor rotates in reverse by swapping the values of Input 1 with Input 2, switching 2 values in the memory. Therefore, LQR controls the roll and pitch angles by making changes to two variables: <code>rollingPWM</code> corresponding to <strong>1,2EN</strong> and <code>reactionPWM</code> corresponding to <strong>3,4EN</strong>. LQR adds / subtracts from the two variables when it acts in the environment. To drive a direct current actuator, the driver generates an electric potential at the two ends of the actuator&#39;s coil. An electric current in the power terminals (<strong>1Y</strong> and <strong>2Y</strong>, or, <strong>3Y</strong> and <strong>4Y</strong>) occurs whenever the electric potential at the two end points are sufficiently different in intensity. The duty cycle of a PWM signal shapes the line graph of an analog voltage. In a Voltage versus Time graph, the PWM signal is a point on the graph and varies with time. There are two independent PWM signals: the reaction wheel&#39;s motor enable pin and the rolling wheel&#39;s motor enable pin. In turn, the duty cycles of the PWM signals, tell the Integrated Circuit (IC) to adjust the electric potential at the output pins of the IC: <strong>1Y</strong>, <strong>2Y</strong>, <strong>3Y</strong> and <strong>4Y</strong>. Making changes to the duty cycles with the given feedback policy <code>u_k</code>, the registers of channels one and two of Timer 2 are changed after scaling the variables and casting them to integer values.</p><p><img src="assets/reactionwheelunicycle/schematics/motordriver.jpeg" alt="motordriver"/></p><p>The control policy takes an action by writing to MCU registers. The MCU is capable of writing to millions of registers in less than one second. However, it takes about 2 to 5 milliseconds to solve for 2 input variables in a multi-input / multi-output system. By integrating the input vector <code>u_k</code> with a suitable step size, the duty cycle becomes approximately continuous. A big pulse step results in overshooting input adjustments in the pursuit of the equiblirium state. Since the harware power (in terms of revolutions per second and output torque) varies from motor to motor, the variable <code>pulseStep</code> helps limit changes to the input. Therefore, fine motor functions are acheived with a calibrated value of the parameter <code>pulseStep</code>.</p><pre><code class="language-c hljs">model-&gt;reactionPWM += (255.0 * pulseStep) * u_k[0];
model-&gt;rollingPWM += (255.0 * pulseStep) * u_k[1];
model-&gt;reactionPWM = fmin(255.0 * 255.0, model-&gt;reactionPWM);
model-&gt;reactionPWM = fmax(-255.0 * 255.0, model-&gt;reactionPWM);
model-&gt;rollingPWM = fmin(255.0 * 255.0, model-&gt;rollingPWM);
model-&gt;rollingPWM = fmax(-255.0 * 255.0, model-&gt;rollingPWM);
TIM2-&gt;CCR1 = (int)fabs(model-&gt;rollingPWM);
TIM2-&gt;CCR2 = (int)fabs(model-&gt;reactionPWM);
if (model-&gt;reactionPWM &lt; 0)
{
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_SET);
}
else
{
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_SET);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
}
if (model-&gt;rollingPWM &lt; 0)
{
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET);
}
else
{
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);
}</code></pre><ul><li></li></ul><p>After the action, the agent begins sensing the environment for feedback. The first to update is the encoder of the reaction wheel. There is an encoder wheel at the opposite the end of the reaction wheel&#39;s motor. Since the gearbox reduces the speed of rotation of the reaction wheel in exchange for multiplying the output torque, the encoder&#39;s wheel rotates faster than the reaction wheel. The difference in the speed of rotation between the output reaction wheel and the input encoder wheel allows the encoder to be more precise. Also in the motor / encoder assembley, there is an array of small magnets on the circumference of the encoder&#39;s wheel. The resolution of the encoder depends on the number of magnets in the circular array and the gearbox ratio. A Hall effect sensor produces a voltage proportional to an axial component of the magnetic field vector produced by the magnetic array. The encoder measures the absolute position of the wheel using two channels. A pair of Hall effect sensors are mounted near the surface of the encoder&#39;s wheel, such that the magnets pass by the Hall effect sensors. Timer 3 of the MCU is set up to work in encoder mode, with a register of the absolute position of the encoder&#39;s wheel. When Timer 3 is in the encoder mode, it compares the pair of channels at each rising edge of the signals to find the position. Therefore, we call the <code>encodeWheel</code> function with a pointer to the <code>Encoder</code> object of the reaction wheel along with the value of the counter register of Timer 3. The function <code>encodeWheel</code> updates the velocity field of the reaction wheel&#39;s encoder struct to be used in the LQR model as a system state.</p><pre><code class="language-c hljs">encodeWheel(&amp;(model-&gt;reactionEncoder), TIM3-&gt;CNT);</code></pre><p><img src="assets/reactionwheelunicycle/schematics/motorb.jpeg" alt="motorb"/></p><ul><li></li></ul><p>The rolling wheel&#39;s encoder works the same as the reaction wheel&#39;s encoder, except for the fact that the hardware of the channels sensors is photonic rather than magnetic. The rolling wheel encoder&#39;s disk has an alternating pattern of stripes on it for a pair of infrared light emmiting diodes and a pair of photo transistors to sense its rotation. The IR LEDs send light from one side of the wheel to be received by photo transistors on the other side through the alternating pattern. The amount of light received by the photo transistors is translated to two channels of representative electrical signals, which are fed to Timer 4 of the MCU. Supplying the <code>encodeWheel</code> function with a pointer to the rolling wheel&#39;s encoder object and the value of the counter register of Timer 4, the function call updates the wheel velocity. Before connecting the encoder signals to the MCU timer, a voltage division is applied for making sure the amplitudes of the signals do not exceed 3.3 volts.</p><pre><code class="language-c hljs">encodeWheel(&amp;(model-&gt;rollingEncoder), TIM4-&gt;CNT);</code></pre><p><img src="assets/reactionwheelunicycle/schematics/motora.jpeg" alt="motora"/></p><ul><li>The <code>senseCurrent</code> function computes the current rates of the reaction and rolling motors. The function accepts two pointers of the <code>CurrentSensor</code> type and updates the <code>currentVelocity</code> field of the respective arguments. Measuring the electric current rate is the result of two Analog to Digital Conversion (ADC) channels, as peripherals of the MCU (pins <code>PC4</code> and <code>PA4</code> of the ADC unit). A pair of Hall effect sensors are powered using a regulated 5-Volt direct current source. To measure the current rate of the driver&#39;s output, two of the wires that connect the driver IC pins (<strong>1Y</strong> and <strong>4Y</strong>) to the respective motor coils (<strong>MotorA2</strong> and <strong>MotorB2</strong>), are routed in such a way that they pass by the respective current sensing Hall effect sensors. When the IC drives a voltage across the motor terminals (<strong>MA1</strong> and <strong>MA2</strong>, or <strong>MB1</strong> and <strong>MB2</strong>), the Hall effect sensors measure the magnetic field vector that is caused by the electric field inside the wires between the motors and the driver. The ratio-metric readings from the magnetic field vectors represent the flows of the electric current of the reaction motor&#39;s and the rolling motor&#39;s coils. The LQR model observes the current rates and regulates them to zero by generating suitable inputs.</li></ul><pre><code class="language-c hljs">senseCurrent(&amp;(model-&gt;reactionCurrentSensor), &amp;(model-&gt;rollingCurrentSensor));</code></pre><p><img src="assets/reactionwheelunicycle/schematics/currentsensing.jpeg" alt="currentsensing"/></p><ul><li></li></ul><p>The function <code>updateIMU</code> provides the main source of data for the objective of the system. Through this function, the MCU talks to the IMU modules 1 and 2 for updating the roll and pitch angles along with their first and second derivatives. This is done by calling the function and giving it a pointer to the LQR model object. Although both IMUs are used for tilt estimation, the final result is assigned to the field of IMU 1. This function encapsulates matrix-vector multiplications for coordinate transformations, the singular value decomposition for obtaining the gravity vector, and sensor fusion between the tri-axis accelerometers and the tri-axis gyroscopes. Knowing about the position and orientation of each IMU with respect to the body, the function excludes linear accelerations from calculations. So, <code>UpdateIMU</code> gathers the latest inertial measurements form multiple sensor units and computes the roll and pitch angles using known parameters of the system configuration.</p><pre><code class="language-c hljs">updateIMU(model);</code></pre><p>In terms of connectivity, The MCU peripheral USART1 is used to talk to IMU #2 (GY-95T). Set the baudrate of uart1 to 115200 Bits/s for the GY-95 IMU module. Set the Pin6 (PS: IIC/USART output mode selection) of IMU #2 (GY-25T) to zero, in order to use the I2C protocol. The I2C cock speed is set at 100000 Hz in the stanard mode. For saving MCU clock cycles and time, added a DMA request with USART1_RX and DMA2 Stream 2 from peripheral to memory and low priority. The mode is circular and the request call is made once in the main function by passing the usart1 handle and the receive buffer. The request increments the address of memory. The data width is one Byte for both the preipheral and memory.</p><p><img src="assets/reactionwheelunicycle/schematics/inertialmeasurementunits.jpeg" alt="inertialmeasurementunits"/></p><ul><li></li></ul><p>Once the action is complete and the sensory information is refreshed, the second half of the data set is assigned. The elements <code>x12</code> through <code>x23</code> mirror the elements <code>x0</code> through <code>x11</code>, with the only difference being the respective time indices <code>k + 1</code> and <code>k</code>. There should be about a 5-millisecond interval between <code>k</code> and <code>k + 1</code>, which is long enough to judge the quality of the action. The two consecutive time steps are separated by an action happening in time step <code>k</code> using the input <code>u_k</code>, and the subsequent sensor measurements.</p><pre><code class="nohighlight hljs">// dataset = (xₖ, uₖ, xₖ₊₁, uₖ₊₁)
model-&gt;dataset.x12 = model-&gt;imu1.roll / M_PI;
model-&gt;dataset.x13 = model-&gt;imu1.roll_velocity / M_PI;
model-&gt;dataset.x14 = model-&gt;imu1.roll_acceleration / M_PI;
model-&gt;dataset.x15 = model-&gt;imu1.pitch / M_PI;
model-&gt;dataset.x16 = model-&gt;imu1.pitch_velocity / M_PI;
model-&gt;dataset.x17 = model-&gt;imu1.pitch_acceleration / M_PI;
model-&gt;dataset.x18 = model-&gt;reactionEncoder.velocity;
model-&gt;dataset.x19 = model-&gt;rollingEncoder.velocity;
model-&gt;dataset.x20 = model-&gt;reactionCurrentSensor.currentVelocity;
model-&gt;dataset.x21 = model-&gt;rollingCurrentSensor.currentVelocity;</code></pre><ul><li></li></ul><p>After the action, the model determines the quality of the system state. The ideal state is where the first half of the data set is approximately equal to zero and at the same time equal to the second half. In other words, the best quality means that each element of the data set with index <code>k</code> is equal to its counterpart element with index <code>k + 1</code>. Unlike the pair of elements <code>x10</code> and <code>x11</code> (input <code>u_k</code> of step <code>k</code>), the pair of elements <code>x22</code> and <code>x23</code> (input <code>u_k1</code> of step <code>k + 1</code>) are not used for action until the next call to the <code>stepForward</code> function. But, one can see that <code>u_k1</code> will be applied to the action of step <code>k + 1</code> at the next <code>stepForward</code> function call, if the <code>j</code> index is the same across the consecutive calls. The input vector <code>u_k1</code> of the time step <code>k + 1</code> is the result of a matrix-vector multiplication between the policy matrix <code>K_j</code> and the next system state vector <code>x_k1</code>. Even though <code>u_k1</code> is not used for action at step <code>k</code>, it informs the model about the future of the system trajectory in case the filter matrix <code>W_n</code> and the inverse auto-correlation matrix <code>P_n</code> are not updated. When the last two elements of the data set (<code>x22</code> and <code>x23</code>) are computed, the value iteration algorithm can calculate an error and correct the priors of the model to find the next filter matrix Wⱼ₊₁, such that the error is minimized.</p><p><span>$j = 0$</span></p><p><span>$u_k = -K^0 x_k$</span></p><p><span>$u_k = -K^j x_k$</span></p><p><span>$u_{k + 1} = -K^j x_{k + 1}$</span></p><pre><code class="language-c hljs">x_k1[0] = model-&gt;dataset.x12;
x_k1[1] = model-&gt;dataset.x13;
x_k1[2] = model-&gt;dataset.x14;
x_k1[3] = model-&gt;dataset.x15;
x_k1[4] = model-&gt;dataset.x16;
x_k1[5] = model-&gt;dataset.x17;
x_k1[6] = model-&gt;dataset.x18;
x_k1[7] = model-&gt;dataset.x19;
x_k1[8] = model-&gt;dataset.x20;
x_k1[9] = model-&gt;dataset.x21;

u_k1[0] = 0.0;
u_k1[1] = 0.0;

for (int i = 0; i &lt; model-&gt;m; i++)
{
  for (int j = 0; j &lt; model-&gt;n; j++)
  {
    u_k1[i] += -K_j[i][j] * x_k1[j];
  }
}

model-&gt;dataset.x22 = u_k1[0];
model-&gt;dataset.x23 = u_k1[1];</code></pre><ul><li></li></ul><p>The data set can be through of as a pair of vectors in an abstract vector space. A vector with index <code>k</code> and another with index <code>k + 1</code>. At this stage, compute the quadratic basis sets ϕ(zₖ) and ϕ(zₖ₊₁). Here, the transformation ϕ is the identity matrix. These are a pair of besis sets that are separated by a policy implementation and so differ in a time index.</p><p><span>$For \ k = 1, 2, ... \ compute$</span></p><p><span>$z_k = {\begin{bmatrix} x_k^T &amp; u_k^T \end{bmatrix}}^T$</span></p><p><span>$\left\{ \begin{array}{l} \phi(z_k) &amp;\\ \phi(z_{k + 1}) \end{array} \right.$</span></p><pre><code class="language-c hljs">z_k[0] = model-&gt;dataset.x0;
z_k[1] = model-&gt;dataset.x1;
z_k[2] = model-&gt;dataset.x2;
z_k[3] = model-&gt;dataset.x3;
z_k[4] = model-&gt;dataset.x4;
z_k[5] = model-&gt;dataset.x5;
z_k[6] = model-&gt;dataset.x6;
z_k[7] = model-&gt;dataset.x7;
z_k[8] = model-&gt;dataset.x8;
z_k[9] = model-&gt;dataset.x9;
z_k[10] = model-&gt;dataset.x10;
z_k[11] = model-&gt;dataset.x11;

z_k1[0] = model-&gt;dataset.x12;
z_k1[1] = model-&gt;dataset.x13;
z_k1[2] = model-&gt;dataset.x14;
z_k1[3] = model-&gt;dataset.x15;
z_k1[4] = model-&gt;dataset.x16;
z_k1[5] = model-&gt;dataset.x17;
z_k1[6] = model-&gt;dataset.x18;
z_k1[7] = model-&gt;dataset.x19;
z_k1[8] = model-&gt;dataset.x20;
z_k1[9] = model-&gt;dataset.x21;
z_k1[10] = model-&gt;dataset.x22;
z_k1[11] = model-&gt;dataset.x23;

for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  basisset0[i] = z_k[i];
  basisset1[i] = z_k1[i];
}</code></pre><p><span>$\textbf{w}_n = \begin{bmatrix} w_n(0) &amp; w_n(1) &amp; \ldots &amp; w_n(p) \end{bmatrix}^T$</span></p><p>The filter coefficients at time <span>$n$</span> minimize</p><p><span>$\Epsilon (n) = \sum_{i = 0}^{n} \lambda^{n - i} | e(i) |^2$</span></p><p>The weighted least squares error</p><p><span>$0 &lt; \lambda \leq 1$</span></p><p>The exponential weighting (forgetting) factor</p><p><span>$e(i) = d(i) - y(i) = d(i) - \textbf{w}_n^T x(i)$</span></p><p><span>$d(i)$</span> is the desired signal at time <span>$i$</span>.</p><p><span>$y(i)$</span> is the filter output at time <span>$i$</span>.</p><p><span>$\textbf{w}_n(k)$</span> the latest set of filter coefficients</p><p>The weights <span>$\textbf{w}_n$</span> are constant over the observation interval <span>$[0, n]$</span>.</p><p><span>$\frac{\partial \Epsilon (n)}{\partial \textbf{w}_n^* (k)} = 0$</span>, minimizing the weighted least squares error for <span>$k = 0, 1, ..., p$</span>.</p><p><span>$\textbf{R}_x(n) \textbf{w}_n = \textbf{r}_{dx}(n)$</span></p><p>The deterministic normal equations <span>$\textbf{R}_x(n) \in \mathbb{R}^{(p + 1) \times (p + 1)}$</span>, defines the optimum filter coefficients.</p><p>The exponentially weighted deterministic autocorrelation matrix for <span>$\textbf{x}(n)$</span></p><p><span>$\textbf{R}_x(n) = \sum_{i = 0}^n \lambda^{n - i} \textbf{x}^*(i) \textbf{x}^T(i)$</span></p><p>The data vector</p><p><span>$\textbf{x}(i) = \begin{bmatrix} x(i) &amp; x(i - 1) &amp; \ldots &amp; x(i - p) \end{bmatrix}^T$</span></p><p><span>$\textbf{r}_{dx}(n)$</span></p><p>The deterministic cross-correlation between <span>$d(n)$</span> and <span>$\textbf{x}(n)$</span></p><p><span>$\textbf{r}_{dx}(n) = \sum_{i = 0}^n \lambda^{n - i} d(i) \textbf{x}^*(i)$</span></p><p>The minimum error <span>$\{\Epsilon(n)\}_{min} = || d(n) ||_\lambda^2 - \textbf{r}_{dx}^H(n) \textbf{w}_n$</span></p><p><span>$|| d(n) ||_\lambda^2$</span> the weighted norm of the vector <span>$d(n) = \begin{bmatrix} d(n) &amp; d(n - 1) &amp; \ldots &amp; d(0) \end{bmatrix}^T$</span></p><p><span>$\textbf{R}_x(n)$</span> and <span>$\textbf{r}_{dx}(n)$</span> depend on <span>$n$</span></p><p>Instead of directly solving the deterministic normal equations <span>$\textbf{R}_x(n) \textbf{w}_n = \textbf{r}_{dx}(n)$</span>, derive a recursive solution for <span>$\textbf{w}_n$</span>:</p><p><span>$\textbf{w}_n = \textbf{w}_{n - 1} + \Delta \textbf{w}_{n - 1}$</span></p><p><span>$\Delta \textbf{w}_{n - 1}$</span> a correction that is applied to the solution at time <span>$n - 1$</span></p><p><span>$\textbf{w}_n = \textbf{R}_x^{-1}(n) \textbf{r}_{dx}(n)$</span></p><p>First derive <span>$\textbf{r}_{dx}(n)$</span> in terms of <span>$\textbf{r}_{dx}(n - 1)$</span>.</p><p>Then derive <span>$\textbf{R}_x^{-1}(n)$</span> in terms of <span>$\textbf{R}_x^{-1}(n - 1)$</span> and the new data vector <span>$\textbf{x}(n)$</span>.</p><p><span>$\textbf{r}_{dx}(n) = \sum_{i = 0}^n \lambda^{n - i} d(i) \textbf{x}^*(i)$</span> the cross-correlation may be updated recursively:</p><p><span>$\textbf{r}_{dx}(n) = \lambda \textbf{r}_{dx}(n - 1) + d(n) \textbf{x}^*(n)$</span></p><p>The autocorrelation matrix <span>$\textbf{R}_x(n)$</span> may be updated recursively from <span>$\textbf{R}_x(n - 1)$</span> and <span>$\textbf{x}(n)$</span>:</p><p><span>$\textbf{R}_x(n) = \lambda \textbf{R}_x(n - 1) + \textbf{x}^*(n) \textbf{x}^T(n)$</span></p><p>Since we are interested in the inverse of <span>$\textbf{R}_x(n)$</span></p><p>Woodbury&#39;s Identity: <span>$(\textbf{A} + \textbf{u} \textbf{v}^H)^{-1} = \textbf{A}^{-1} - \frac{\textbf{A}^{-1} \textbf{u} \textbf{v}^H \textbf{A}^{-1}}{1 + \textbf{v}^H \textbf{A}^{-1} \textbf{u}}$</span></p><p><span>$\left\{ \begin{array}{l} \textbf{A} = \lambda \textbf{R}_x(n - 1) &amp;\\ \textbf{u} = \textbf{v} = \textbf{x}^*(n) \end{array} \right.$</span></p><p><span>$\textbf{R}_x^{-1}(n) = \lambda^{-1} \textbf{R}_x^{-1} (n - 1) - \frac{\lambda^{-2} \textbf{R}_x^{-1} (n - 1) \textbf{x}^*(n) \textbf{x}^T(n) \textbf{R}_x^{-1}(n - 1)}{1 + \lambda^{-1} \textbf{x}^T(n) \textbf{R}_x^{-1}(n - 1) \textbf{x}^*(n)}$</span></p><p><span>$\textbf{P}(n)$</span> is the inverse of the autocorrelation matrix at time <span>$n$</span>.</p><p><span>$\textbf{P}(n) = \textbf{R}_x^{-1}(n)$</span></p><p>The gain vector <span>$\textbf{g}(n) = \frac{\lambda^{-1} \textbf{P}(n - 1) \textbf{x}^*(n)}{1 + \lambda^{-1} \textbf{x}^T(n) \textbf{P}(n - 1) \textbf{x}^*(n)}$</span></p><p><span>$\textbf{P}(n) = \lambda^{-1} [\textbf{P}(n - 1) - \textbf{g}(n) \textbf{x}^T(n) \textbf{P}(n -1)]$</span></p><p><span>$\textbf{g}(n) = \textbf{P}(n) \textbf{x}^*(n)$</span></p><p>The gain vector is the solution to the equations <span>$\textbf{R}_x(n) \textbf{g}(n) = \textbf{x}^*(n)$</span>.</p><p>This is the same as the deterministic normal equations <span>$\textbf{R}_x(n) \textbf{w}_n = \textbf{r}_{dx}(n)$</span> , but the cross-correlation vector <span>$\textbf{r}_{dx}(n)$</span> is replaced with the data vector <span>$\textbf{x}^*(n)$</span></p><p>The final derivation to complete the recursion.</p><p>The time-update equation for the coefficient vector <span>$\textbf{w}_n$</span></p><p><span>$\left\{ \begin{array}{l} \textbf{w}_n = \textbf{P}(n) \textbf{r}_{dx}(n) &amp;\\ \textbf{r}_{dx}(n) = \lambda \textbf{r}_{dx}(n - 1) + d(n) \textbf{x}^*(n) \end{array} \right.$</span></p><p><span>$\textbf{w}_n = \lambda \textbf{P}(n) \textbf{r}_{dx}(n - 1) + d(n) \textbf{P}(n) \textbf{x}^*(n)$</span></p><p><span>$\left\{ \begin{array}{l} \textbf{P}(n) \textbf{x}^*(n) = \textbf{g}(n) &amp;\\ \textbf{P}(n) = \lambda^{-1} [\textbf{P}(n - 1) - \textbf{g}(n) \textbf{x}^T(n) \textbf{P}(n - 1)] \end{array} \right.$</span></p><p><span>$\textbf{w}_n = [\textbf{P}(n - 1) - \textbf{g}(n) \textbf{x}^T(n) \textbf{P}(n - 1)] \textbf{r}_{dx}(n - 1) + d(n) \textbf{g}(n)$</span></p><p><span>$\textbf{P}(n - 1) \textbf{r}_{dx}(n - 1) = \textbf{w}_{n - 1}$</span></p><p><span>$\textbf{w}_n = \textbf{w}_{n - 1} + \textbf{g}(n) [d(n) - \textbf{w}_{n - 1}^T \textbf{x}(n)]$</span></p><p><span>$\textbf{w}_n = \textbf{w}_{n - 1} + \alpha(n) \textbf{g}(n)$</span></p><p><span>$\alpha(n) = d(n) - \textbf{w}_{n - 1}^T \textbf{x}(n)$</span> the <em>a priori error</em></p><p><span>$\textbf{w}_{n - 1}^T \textbf{x}(n)$</span> the estimate of <span>$d(n)$</span> using previous set of filter coefficients <span>$\textbf{w}_{n - 1}$</span></p><p><span>$\left\{ \begin{array}{l} \alpha(n) = d(n) - \textbf{w}_{n - 1}^T \textbf{x}(n) &amp;\\ e(n) = d(n) - \textbf{w}_n^T \textbf{x}(n) \end{array} \right.$</span></p><p><span>$\alpha(n)$</span> the <em>a priori error</em>: the error that would occur if the filter coefficients were not updated.</p><p><span>$e(n)$</span> the <em>a posteriori error</em>: the error that occurs after the weight vector <span>$\textbf{w}_n$</span> is updated</p><p>A simplification:</p><p><span>$\left\{ \begin{array}{l} \textbf{g}(n) = \frac{\lambda^{-1} \textbf{P}(n - 1) \textbf{x}^*(n)}{1 + \lambda^{-1} \textbf{x}^T(n) \textbf{P}(n - 1) \textbf{x}^*(n)} &amp;\\ \textbf{P}(n) = \lambda^{-1} [\textbf{P}(n - 1) - \textbf{g}(n) \textbf{x}^T(n) \textbf{P}(n - 1)] \end{array} \right.$</span></p><p><span>$\textbf{z}(n) = \textbf{P}(n - 1) \textbf{x}^*(n)$</span> filtered information vector</p><p><span>$\left\{ \begin{array}{l} \textbf{g}(n) = \frac{1}{\lambda + \textbf{x}^T(n) \textbf{z}(n)} \textbf{z}(n) &amp;\\ \textbf{P}(n) = \frac{1}{\lambda} [\textbf{P}(n - 1) - \textbf{g}(n) \textbf{z}^H(n)] \end{array} \right.$</span></p><p>The exponentially weighted Recursive Least Squares (RLS) algorithm:</p><p><span>$\left\{ \begin{array}{l} \textbf{z}(n) = \textbf{P}(n - 1) \textbf{x}^*(n) &amp;\\ \alpha(n) = d(n) - \textbf{w}_{n - 1}^T \textbf{x}(n) &amp;\\ \textbf{g}(n) = \frac{1}{\lambda + \textbf{x}^T(n) \textbf{z}(n)} \textbf{z}(n) &amp;\\ \textbf{w}_n = \textbf{w}_{n - 1} + \alpha(n) \textbf{g}(n) &amp;\\ \textbf{P}(n) = \frac{1}{\lambda} [\textbf{P}(n - 1) - \textbf{g}(n) \textbf{z}^H(n)] \end{array} \right.$</span></p><p><span>$\lambda = 1$</span> the growing window RLS algorithm</p><p>Recursive updating of <span>$\textbf{w}_n$</span> and <span>$\textbf{P}(n)$</span> requires initial conditions for both terms.</p><p><span>$\textbf{R}_x(0) = \delta \textbf{I}$</span>, <span>$\delta$</span> small positive constant</p><p><span>$\textbf{P}(0) = \delta^{-1} \textbf{I}$</span></p><p><span>$\textbf{w}_0 = \textbf{0}$</span></p><p>The initial zero vector of the filter coefficients does not minimize the weighted least squares error <span>$\Epsilon(0)$</span> and so <span>$\textbf{w}_0$</span> is not an optimal initial vector.</p><p>With an exponential weighting factor <span>$\lambda &lt; 1$</span> the bias in the least squares solution goes to zero as <span>$n$</span> increases.</p><ul><li></li></ul><p><span>$W_{j + 1}^T (\phi (z_k) - \gamma \phi (z_{k + 1})) = r (x_k, h_j(x_k))$</span></p><p><span>$h_{j + 1} (x_k) = \underset{u}{arg \ min} (W_{j + 1}^T \phi (x_k, u))$</span>, for all <span>$x \in X$</span></p><p><span>$Q(x_k, u_k) = Q(z_k) \equiv (\frac{1}{2}) z_k^T S z_k$</span></p><p><span>$Q(x_k, u_k) = \frac{1}{2} \begin{bmatrix} x_k \\ u_k \end{bmatrix} \begin{bmatrix} A^T P A + Q &amp; B^T P A \\ A^T P B &amp; B^T P B + R \end{bmatrix} \begin{bmatrix} x_k \\ u_k \end{bmatrix}$</span></p><p><span>$Q(x, u) = Q(z) = W^T \phi(z)$</span></p><p><span>$x_k \in \mathbb{R^n}, \ u_k \in \mathbb{R^m} \longrightarrow length(W) = (n + m) (n + m + 1) / 2$</span></p><p><span>$W_{j + 1}^T (\phi(z_k) - \gamma \phi(z_{k + 1})) = r(x_k, h_j(x_k))$</span></p><p><span>$W_{j + 1}^T (\phi(z_k) - \phi(z_{k + 1})) = \frac{1}{2} (x_k^T Q x_k + u_k^T R u_k)$</span></p><p><span>$n (n + 1) / 2$</span></p><p>Perform a one-step update in the parameter vector W by applying RLS to equation.</p><p><span>$Q(x_k, u_k) = \frac{1}{2} {\begin{bmatrix} x_k \\ u_k \end{bmatrix}}^T S \begin{bmatrix} x_k \\ u_k \end{bmatrix} = \frac{1}{2} {\begin{bmatrix} x_k \\ u_k \end{bmatrix}}^T \begin{bmatrix} S_{xx} &amp; S_{xu} \\ S_{ux} &amp; S_{uu} \end{bmatrix} \begin{bmatrix} x_k \\ u_k \end{bmatrix}$</span></p><pre><code class="language-c hljs">for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  z_n[i] = 0.0;
}
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
  {
    z_n[i] += getIndex(model-&gt;P_n, i, j) * z_k1[j];
  }
}

z_k_dot_z_n = 0.0;
float buffer = 0.0;
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  buffer = z_k1[i] * z_n[i];
  if (isnanf(buffer) == 0)
  {
    z_k_dot_z_n += buffer;
  }
}

if (fabs(model-&gt;lambda + z_k_dot_z_n) &gt; 0)
{
  for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
  {
    g_n[i] = (1.0 / (model-&gt;lambda + z_k_dot_z_n)) * z_n[i];
  }
}
else
{
  for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
  {
    g_n[i] = (1.0 / model-&gt;lambda) * z_n[i];
  }
}

for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  alpha_n[i] = 0.0;
}
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
  {
    alpha_n[i] +=  0.0 - getIndex(model-&gt;W_n, i, j) * basisset1[j];
  }
}

for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
  {
    buffer = getIndex(model-&gt;W_n, i, j) + (alpha_n[i] * g_n[j]);
    if (isnanf(buffer) == 0)
    {
      setIndex(&amp;(model-&gt;W_n), i, j, buffer);
    }
  }
}

int scaleFlag = 0;
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
  {
    buffer = (1.0 / model-&gt;lambda) * (getIndex(model-&gt;P_n, i, j) - g_n[i] * z_n[j]);
    if (isnanf(buffer) == 0)
    {
      if (fabs(buffer) &gt; clipping)
      {
        scaleFlag = 1;
      }
      setIndex(&amp;(model-&gt;P_n), i, j, buffer);
    }
  }
}
if (scaleFlag == 1)
{
  for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
  {
    for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
    {
      setIndex(&amp;(model-&gt;P_n), i, j, clippingFactor * getIndex(model-&gt;P_n, i, j));
    }
  }
}</code></pre><ul><li></li></ul><p>The counter variable <code>k</code> is incremented every time the <code>stepForward</code> function is called for keeping track of the number of steps in an episode. This reminds us of the counter variable <code>j</code>, which counts the number of policy updates in the function <code>updateControlPolicy</code>. In the <code>stepForward</code> function, the variable <code>k</code> is incremented before returning to the <code>main</code> function. Repeat at the next time <code>k + 1</code> and continue until RLS converges and the new parameter vector Wⱼ₊₁ is found.</p><pre><code class="language-c hljs">model-&gt;k = model-&gt;k + 1;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">typedef struct
{
  float row0[N + M];
  float row1[N + M];
  float row2[N + M];
  float row3[N + M];
  float row4[N + M];
  float row5[N + M];
  float row6[N + M];
  float row7[N + M];
  float row8[N + M];
  float row9[N + M];
  float row10[N + M];
  float row11[N + M];
} Mat12;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float getIndex(Mat12 matrix, int i, int j)
void setIndex(Mat12 *matrix, int i, int j, float value)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void updateControlPolicy(LinearQuadraticRegulator *model)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// unpack the vector Wⱼ₊₁ into the kernel matrix
// Q(xₖ, uₖ) ≡ 0.5 * transpose([xₖ; uₖ]) * S * [xₖ; uₖ] = 0.5 * transpose([xₖ; uₖ]) * [Sₓₓ Sₓᵤ; Sᵤₓ Sᵤᵤ] * [xₖ; uₖ]
model-&gt;k = 1;
model-&gt;j = model-&gt;j + 1;</code></pre><ul><li></li></ul><p><span>$u_k = -S_{uu}^{-1} S_{ux} x_k$</span></p><pre><code class="language-c hljs">// initialize the filter matrix
// putBuffer(model-&gt;m + model-&gt;n, model-&gt;m + model-&gt;n, W_n, model-&gt;W_n);

for (int i = 0; i &lt; model-&gt;m; i++)
{
  for (int j = 0; j &lt; model-&gt;n; j++)
  {
    S_ux[i][j] = getIndex(model-&gt;W_n, model-&gt;n + i, j);
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; model-&gt;m; i++)
{
  for (int j = 0; j &lt; model-&gt;m; j++)
  {
    S_uu[i][j] = getIndex(model-&gt;W_n, model-&gt;n + i, model-&gt;n + j);
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Perform the control update using (S24), which is uₖ = -S⁻¹ᵤᵤ * Sᵤₓ * xₖ
// uₖ = -S⁻¹ᵤᵤ * Sᵤₓ * xₖ
float determinant = S_uu[1][1] * S_uu[2][2] - S_uu[1][2] * S_uu[2][1];
// check the rank of S_uu to see if it&#39;s equal to 2 (invertible matrix)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (fabs(determinant) &gt; 0.0001) // greater than zero
{
  S_uu_inverse[0][0] = S_uu[1][1] / determinant;
  S_uu_inverse[0][1] = -S_uu[0][1] / determinant;
  S_uu_inverse[1][0] = -S_uu[1][0] / determinant;
  S_uu_inverse[1][1] = S_uu[0][0] / determinant;
  // initialize the gain matrix
  for (int i = 0; i &lt; model-&gt;m; i++)
  {
    for (int j = 0; j &lt; model-&gt;n; j++)
    {
      K_j[i][j] = 0.0;
    }
  }
  for (int i = 0; i &lt; model-&gt;m; i++)
  {
    for (int j = 0; j &lt; model-&gt;n; j++)
    {
      for (int k = 0; k &lt; model-&gt;m; k++)
      {
        K_j[i][j] += S_uu_inverse[i][k] * S_ux[k][j];
      }
    }
  }
  model-&gt;K_j.x00 = K_j[0][0];
  model-&gt;K_j.x01 = K_j[0][1];
  model-&gt;K_j.x02 = K_j[0][2];
  model-&gt;K_j.x03 = K_j[0][3];
  model-&gt;K_j.x04 = K_j[0][4];
  model-&gt;K_j.x05 = K_j[0][5];
  model-&gt;K_j.x06 = K_j[0][6];
  model-&gt;K_j.x07 = K_j[0][7];
  model-&gt;K_j.x08 = K_j[0][8];
  model-&gt;K_j.x09 = K_j[0][9];
  model-&gt;K_j.x10 = K_j[1][0];
  model-&gt;K_j.x11 = K_j[1][1];
  model-&gt;K_j.x12 = K_j[1][2];
  model-&gt;K_j.x13 = K_j[1][3];
  model-&gt;K_j.x14 = K_j[1][4];
  model-&gt;K_j.x15 = K_j[1][5];
  model-&gt;K_j.x16 = K_j[1][6];
  model-&gt;K_j.x17 = K_j[1][7];
  model-&gt;K_j.x18 = K_j[1][8];
  model-&gt;K_j.x19 = K_j[1][9];
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// instantiate a model and initialize it
LinearQuadraticRegulator model;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Represents a Linear Quadratic Regulator (LQR) model.
typedef struct
{
  Mat12 W_n;                           // filter matrix
  Mat12 P_n;                           // inverse autocorrelation matrix
  Mat210f K_j;                         // feedback policy
  Vec24f dataset;                      // (xₖ, uₖ, xₖ₊₁, uₖ₊₁)
  int j;                               // step number
  int k;                               // time k
  int n;                               // xₖ ∈ ℝⁿ
  int m;                               // uₖ ∈ ℝᵐ
  float lambda;                        // exponential wighting factor
  float delta;                         // value used to intialize P(0)
  int active;                          // is the model controller active
  float dt;                            // period in seconds
  float reactionPWM;                   // reaction wheel&#39;s motor PWM duty cycle
  float rollingPWM;                    // rolling wheel&#39;s motor PWM duty cycle
  IMU imu1;                            // the first inertial measurement unit
  IMU imu2;                            // the second inertial measurement unit
  Encoder reactionEncoder;             // the reaction wheel encoder
  Encoder rollingEncoder;              // the rolling wheel encoder
  CurrentSensor reactionCurrentSensor; // the reaction wheel&#39;s motor current sensor
  CurrentSensor rollingCurrentSensor;  // the rolling wheel&#39;s motor current sensor
} LinearQuadraticRegulator;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void updateIMU(LinearQuadraticRegulator *model)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">updateIMU1(&amp;(model-&gt;imu1));
updateIMU2(&amp;(model-&gt;imu2));</code></pre><ul><li></li></ul><pre><code class="language-c hljs">typedef struct
{
  int16_t accX_offset;
  int16_t accY_offset;
  int16_t accZ_offset;
  float accX_scale;
  float accY_scale;
  float accZ_scale;
  int16_t gyrX_offset;
  int16_t gyrY_offset;
  int16_t gyrZ_offset;
  float gyrX_scale;
  float gyrY_scale;
  float gyrZ_scale;
  int16_t rawAccX;
  int16_t rawAccY;
  int16_t rawAccZ;
  int16_t rawGyrX;
  int16_t rawGyrY;
  int16_t rawGyrZ;
  float accX;
  float accY;
  float accZ;
  float gyrX;
  float gyrY;
  float gyrZ;
  float roll;
  float pitch;
  float yaw;
  float roll_velocity;
  float pitch_velocity;
  float yaw_velocity;
  float roll_acceleration;
  float pitch_acceleration;
  float yaw_acceleration;
} IMU;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">R1[0] = model-&gt;imu1.accX;
R1[1] = model-&gt;imu1.accY;
R1[2] = model-&gt;imu1.accZ;
R2[0] = model-&gt;imu2.accX;
R2[1] = model-&gt;imu2.accY;
R2[2] = model-&gt;imu2.accZ;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">_R1[0] = 0.0;
_R1[1] = 0.0;
_R1[2] = 0.0;
_R2[0] = 0.0;
_R2[1] = 0.0;
_R2[2] = 0.0;
for (int i = 0; i &lt; 3; i++)
{
  for (int j = 0; j &lt; 3; j++)
  {
    _R1[i] += B_A1_R[i][j] * R1[j];
    _R2[i] += B_A2_R[i][j] * R2[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; 3; i++)
{
  Matrix[i][0] = _R1[i];
  Matrix[i][1] = _R2[i];
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; 3; i++)
{
  for (int j = 0; j &lt; 4; j++)
  {
    Q[i][j] = 0.0;
    for (int k = 0; k &lt; 2; k++)
    {
      Q[i][j] += Matrix[i][k] * X[k][j];
    }
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">g[0] = Q[0][0];
g[1] = Q[1][0];
g[2] = Q[2][0];</code></pre><ul><li></li></ul><pre><code class="language-c hljs">beta = atan2(-g[0], sqrt(pow(g[1], 2) + pow(g[2], 2)));</code></pre><ul><li></li></ul><pre><code class="language-c hljs">gamma1 = atan2(g[1], g[2]);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">G1[0] = model-&gt;imu1.gyrX;
G1[1] = model-&gt;imu1.gyrY;
G1[2] = model-&gt;imu1.gyrZ;
G2[0] = model-&gt;imu2.gyrX;
G2[1] = model-&gt;imu2.gyrY;
G2[2] = model-&gt;imu2.gyrZ;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">_G1[0] = 0.0;
_G1[1] = 0.0;
_G1[2] = 0.0;
_G2[0] = 0.0;
_G2[1] = 0.0;
_G2[2] = 0.0;
for (int i = 0; i &lt; 3; i++)
{
  for (int j = 0; j &lt; 3; j++)
  {
    _G1[i] += B_A1_R[i][j] * G1[j];
    _G2[i] += B_A2_R[i][j] * G2[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; 3; i++)
{
  r[i] = (_G1[i] + _G2[i]) / 2.0;
}</code></pre><ul><li></li></ul><pre><code class="nohighlight hljs">E[0][0] = 0.0;
E[0][1] = sin(gamma1) / cos(beta);
E[0][2] = cos(gamma1) / cos(beta);
E[1][0] = 0.0;
E[1][1] = cos(gamma1);
E[1][2] = -sin(gamma1);
E[2][0] = 1.0;
E[2][1] = sin(gamma1) * tan(beta);
E[2][2] = cos(gamma1) * tan(beta);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">r_dot[0] = 0.0;
r_dot[1] = 0.0;
r_dot[2] = 0.0;
for (int i = 0; i &lt; 3; i++)
{
  for (int j = 0; j &lt; 3; j++)
  {
    r_dot[i] += E[i][j] * r[j];
    r_dot[i] += E[i][j] * r[j];
    r_dot[i] += E[i][j] * r[j];
    r_dot[i] += E[i][j] * r[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">fused_beta = kappa1 * beta + (1.0 - kappa1) * (fused_beta + model-&gt;dt * (r_dot[1] / 180.0 * M_PI));</code></pre><ul><li></li></ul><pre><code class="language-c hljs">fused_gamma = kappa2 * gamma1 + (1.0 - kappa2) * (fused_gamma + model-&gt;dt * (r_dot[2] / 180.0 * M_PI));</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float _roll = fused_beta;
float _pitch = -fused_gamma;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float _roll_velocity = ((r_dot[1] / 180.0 * M_PI) + (_roll - model-&gt;imu1.roll) / model-&gt;dt) / 2.0;
float _pitch_velocity = ((-r_dot[2] / 180.0 * M_PI) + (_pitch - model-&gt;imu1.pitch) / model-&gt;dt) / 2.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;imu1.roll_acceleration = _roll_velocity - model-&gt;imu1.roll_velocity;
model-&gt;imu1.pitch_acceleration = _pitch_velocity - model-&gt;imu1.pitch_velocity;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;imu1.roll_velocity = _roll_velocity;
model-&gt;imu1.pitch_velocity = _pitch_velocity;
model-&gt;imu1.roll = _roll;
model-&gt;imu1.pitch = _pitch;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">typedef struct
{
  int pulse_per_revolution; // the number of pulses per revolution
  int value;                // the counter
  float radianAngle;        // the angle in radian
  float angle;              // the absolute angle
  float velocity;           // the angular velocity
  float acceleration;       // the angular acceleration
} Encoder;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void encodeWheel(Encoder *encoder, int newValue)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">encoder-&gt;value = newValue;
encoder-&gt;radianAngle = (float)(encoder-&gt;value % encoder-&gt;pulse_per_revolution) / (float)encoder-&gt;pulse_per_revolution * 2.0 * M_PI;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float angle = sin(encoder-&gt;radianAngle);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float velocity = angle - encoder-&gt;angle;
float acceleration = velocity - encoder-&gt;velocity;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">encoder-&gt;angle = angle;
encoder-&gt;velocity = velocity;
encoder-&gt;acceleration = acceleration;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">typedef struct
{
  float currentScale;
  int current0;
  int current1;
  float currentVelocity;
} CurrentSensor;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void senseCurrent(CurrentSensor *reactionCurrentSensor, CurrentSensor *rollingCurrentSensor)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Start ADC Conversion in DMA Mode (Periodically Every 1ms)
HAL_ADC_Start_DMA(&amp;hadc1, AD_RES_BUFFER, 2);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">reactionCurrentSensor-&gt;current1 = reactionCurrentSensor-&gt;current0;
rollingCurrentSensor-&gt;current1 = rollingCurrentSensor-&gt;current0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">reactionCurrentSensor-&gt;current0 = (AD_RES_BUFFER[0] &lt;&lt; 4);
rollingCurrentSensor-&gt;current0 = (AD_RES_BUFFER[1] &lt;&lt; 4);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">reactionCurrentSensor-&gt;currentVelocity = (float)(reactionCurrentSensor-&gt;current0 - reactionCurrentSensor-&gt;current1) / reactionCurrentSensor-&gt;currentScale;
rollingCurrentSensor-&gt;currentVelocity = (float)(rollingCurrentSensor-&gt;current0 - rollingCurrentSensor-&gt;current1) / rollingCurrentSensor-&gt;currentScale;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void updateIMU1(IMU *sensor) // GY-25 I2C</code></pre><ul><li></li></ul><pre><code class="language-c hljs">do
{
  HAL_I2C_Master_Transmit(&amp;hi2c1, (uint16_t)SLAVE_ADDRESS, (uint8_t *)&amp;transferRequest, 1, 10);
  while (HAL_I2C_GetState(&amp;hi2c1) != HAL_I2C_STATE_READY)
    ;
} while (HAL_I2C_GetError(&amp;hi2c1) == HAL_I2C_ERROR_AF);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">do
{
  HAL_I2C_Master_Receive(&amp;hi2c1, (uint16_t)SLAVE_ADDRESS, (uint8_t *)raw_data, 12, 10);
  while (HAL_I2C_GetState(&amp;hi2c1) != HAL_I2C_STATE_READY)
    ;
  sensor-&gt;rawAccX = (raw_data[0] &lt;&lt; 8) | raw_data[1];
  sensor-&gt;rawAccY = (raw_data[2] &lt;&lt; 8) | raw_data[3];
  sensor-&gt;rawAccZ = (raw_data[4] &lt;&lt; 8) | raw_data[5];
  sensor-&gt;rawGyrX = (raw_data[6] &lt;&lt; 8) | raw_data[7];
  sensor-&gt;rawGyrY = (raw_data[8] &lt;&lt; 8) | raw_data[9];
  sensor-&gt;rawGyrZ = (raw_data[10] &lt;&lt; 8) | raw_data[11];
  sensor-&gt;accX = sensor-&gt;accX_scale * (sensor-&gt;rawAccX - sensor-&gt;accX_offset);
  sensor-&gt;accY = sensor-&gt;accY_scale * (sensor-&gt;rawAccY - sensor-&gt;accY_offset);
  sensor-&gt;accZ = sensor-&gt;accZ_scale * (sensor-&gt;rawAccZ - sensor-&gt;accZ_offset);
  sensor-&gt;gyrX = sensor-&gt;gyrX_scale * (sensor-&gt;rawGyrX - sensor-&gt;gyrX_offset);
  sensor-&gt;gyrY = sensor-&gt;gyrY_scale * (sensor-&gt;rawGyrY - sensor-&gt;gyrY_offset);
  sensor-&gt;gyrZ = sensor-&gt;gyrZ_scale * (sensor-&gt;rawGyrZ - sensor-&gt;gyrZ_offset);
} while (HAL_I2C_GetError(&amp;hi2c1) == HAL_I2C_ERROR_AF);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void updateIMU2(IMU *sensor) // GY-95 USART</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (uart_receive_ok == 1)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (UART1_rxBuffer[0] == UART1_txBuffer[0] &amp;&amp; UART1_rxBuffer[1] == UART1_txBuffer[1] &amp;&amp; UART1_rxBuffer[2] == UART1_txBuffer[2] &amp;&amp; UART1_rxBuffer[3] == UART1_txBuffer[3])</code></pre><ul><li></li></ul><pre><code class="language-c hljs">sensor-&gt;rawAccX = (UART1_rxBuffer[5] &lt;&lt; 8) | UART1_rxBuffer[4];
sensor-&gt;rawAccY = (UART1_rxBuffer[7] &lt;&lt; 8) | UART1_rxBuffer[6];
sensor-&gt;rawAccZ = (UART1_rxBuffer[9] &lt;&lt; 8) | UART1_rxBuffer[8];
sensor-&gt;rawGyrX = (UART1_rxBuffer[11] &lt;&lt; 8) | UART1_rxBuffer[10];
sensor-&gt;rawGyrY = (UART1_rxBuffer[13] &lt;&lt; 8) | UART1_rxBuffer[12];
sensor-&gt;rawGyrZ = (UART1_rxBuffer[15] &lt;&lt; 8) | UART1_rxBuffer[14];</code></pre><ul><li></li></ul><pre><code class="language-c hljs">sensor-&gt;accX = sensor-&gt;accX_scale * (sensor-&gt;rawAccX - sensor-&gt;accX_offset);
sensor-&gt;accY = sensor-&gt;accY_scale * (sensor-&gt;rawAccY - sensor-&gt;accY_offset);
sensor-&gt;accZ = sensor-&gt;accZ_scale * (sensor-&gt;rawAccZ - sensor-&gt;accZ_offset);
sensor-&gt;gyrX = sensor-&gt;gyrX_scale * (sensor-&gt;rawGyrX - sensor-&gt;gyrX_offset);
sensor-&gt;gyrY = sensor-&gt;gyrY_scale * (sensor-&gt;rawGyrY - sensor-&gt;gyrY_offset);
sensor-&gt;gyrZ = sensor-&gt;gyrZ_scale * (sensor-&gt;rawGyrZ - sensor-&gt;gyrZ_offset);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float dummyx = cos(sensorAngle) * sensor-&gt;accX - sin(sensorAngle) * sensor-&gt;accY;
float dummyy = sin(sensorAngle) * sensor-&gt;accX + cos(sensorAngle) * sensor-&gt;accY;
sensor-&gt;accX = -dummyy;
sensor-&gt;accY = dummyx;
dummyx = cos(sensorAngle) * sensor-&gt;gyrX - sin(sensorAngle) * sensor-&gt;gyrY;
dummyy = sin(sensorAngle) * sensor-&gt;gyrX + cos(sensorAngle) * sensor-&gt;gyrY;
sensor-&gt;gyrX = -dummyy;
sensor-&gt;gyrY = dummyx;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">uart_receive_ok = 0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (uart_receive_ok == 0 &amp;&amp; huart-&gt;Instance == USART1)
  {
    uart_receive_ok = 1;
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Initialize the randomizer using the current timestamp as a seed
// (The time() function is provided by the &lt;time.h&gt; header file)
// srand(time(NULL));
void initialize(LinearQuadraticRegulator *model)</code></pre><ul><li></li></ul><p><span>$p = Filter \ order$</span></p><p><span>$\lambda = Exponential \ weighting \ factor$</span></p><p><span>$\delta = Value \ used \ to \ initialize \ \textbf{P}(0)$</span></p><pre><code class="language-c hljs">model-&gt;j = 1;
model-&gt;k = 1;
model-&gt;n = dim_n;
model-&gt;m = dim_m;
model-&gt;lambda = 0.99;
model-&gt;delta = 0.01;
model-&gt;active = 0;
model-&gt;dt = 0.0;</code></pre><ul><li></li></ul><p><span>$\textbf{w}_0 = \textbf{0}$</span></p><p><span>$\textbf{P}(0) = \delta^{-1} \textbf{I}$</span></p><pre><code class="language-c hljs">for (int i = 0; i &lt; (model-&gt;n + model-&gt;n); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;n); j++)
  {
    setIndex(&amp;(model-&gt;W_n), i, j, (float)(rand() % 100) / 100.0);
    if (i == j)
    {
      setIndex(&amp;(model-&gt;P_n), i, j, 1.0);
    }
    else
    {
      setIndex(&amp;(model-&gt;P_n), i, j, 0.0);
    }
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;K_j.x00 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x01 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x02 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x03 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x04 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x05 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x06 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x07 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x08 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x09 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x10 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x11 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x12 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x13 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x14 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x15 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x16 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x17 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x18 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x19 = (float)(rand() % 100) / 100.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;dataset.x0 = 0.0;
model-&gt;dataset.x1 = 0.0;
model-&gt;dataset.x2 = 0.0;
model-&gt;dataset.x3 = 0.0;
model-&gt;dataset.x4 = 0.0;
model-&gt;dataset.x5 = 0.0;
model-&gt;dataset.x6 = 0.0;
model-&gt;dataset.x7 = 0.0;
model-&gt;dataset.x8 = 0.0;
model-&gt;dataset.x9 = 0.0;
model-&gt;dataset.x10 = 0.0;
model-&gt;dataset.x11 = 0.0;
model-&gt;dataset.x12 = 0.0;
model-&gt;dataset.x13 = 0.0;
model-&gt;dataset.x14 = 0.0;
model-&gt;dataset.x15 = 0.0;
model-&gt;dataset.x16 = 0.0;
model-&gt;dataset.x17 = 0.0;
model-&gt;dataset.x18 = 0.0;
model-&gt;dataset.x19 = 0.0;
model-&gt;dataset.x20 = 0.0;
model-&gt;dataset.x21 = 0.0;
model-&gt;dataset.x22 = 0.0;
model-&gt;dataset.x23 = 0.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// scale : 1 / 2048
IMU imu1 = {-24, -60, 27, 0.000488281, 0.000488281, 0.000488281, 0, 0, 0, 0.017444444, 0.017444444, 0.017444444, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
IMU imu2 = {75, -25, -18, 0.000488281, 0.000488281, 0.000488281, 0, 0, 0, 0.017444444, 0.017444444, 0.017444444, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};</code></pre><ul><li></li></ul><pre><code class="language-c hljs">Encoder reactionEncoder = {1736, 0, 0, 0, 0, 0};
Encoder rollingEncoder = {3020, 0, 0, 0, 0, 0};</code></pre><ul><li></li></ul><pre><code class="language-c hljs">CurrentSensor reactionCurrentSensor = {32000.0, 0, 0, 0};
CurrentSensor rollingCurrentSensor = {32000.0, 0, 0, 0};</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;imu1 = imu1;
model-&gt;imu2 = imu2;
model-&gt;reactionEncoder = reactionEncoder;
model-&gt;rollingEncoder = rollingEncoder;
model-&gt;reactionCurrentSensor = reactionCurrentSensor;
model-&gt;rollingCurrentSensor = rollingCurrentSensor;
model-&gt;reactionPWM = 0.0;
model-&gt;rollingPWM = 0.0;</code></pre><h2 id="The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters"><a class="docs-heading-anchor" href="#The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters">The Convergence of Selected Algebraic Riccati Equation Solution Parameters</a><a id="The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters" title="Permalink"></a></h2><p>Convergence of selected algebraic Riccati equation solution parameters. The adaptive controller based on value iteration converges to the ARE solution in real time without knowing the system matrix (including the inertia matrix, and the torque and the electromotive force constants of the motors.)</p><h2 id="The-Controllability-of-the-Z-Euler-Angle"><a class="docs-heading-anchor" href="#The-Controllability-of-the-Z-Euler-Angle">The Controllability of the Z-Euler Angle</a><a id="The-Controllability-of-the-Z-Euler-Angle-1"></a><a class="docs-heading-anchor-permalink" href="#The-Controllability-of-the-Z-Euler-Angle" title="Permalink"></a></h2><h2 id="Nonholonomic-Motion-Planning"><a class="docs-heading-anchor" href="#Nonholonomic-Motion-Planning">Nonholonomic Motion Planning</a><a id="Nonholonomic-Motion-Planning-1"></a><a class="docs-heading-anchor-permalink" href="#Nonholonomic-Motion-Planning" title="Permalink"></a></h2><h2 id="Steering-Using-Sinusoids"><a class="docs-heading-anchor" href="#Steering-Using-Sinusoids">Steering Using Sinusoids</a><a id="Steering-Using-Sinusoids-1"></a><a class="docs-heading-anchor-permalink" href="#Steering-Using-Sinusoids" title="Permalink"></a></h2><h2 id="Steering-Second-Order-Canonical-Systems"><a class="docs-heading-anchor" href="#Steering-Second-Order-Canonical-Systems">Steering Second-Order Canonical Systems</a><a id="Steering-Second-Order-Canonical-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Steering-Second-Order-Canonical-Systems" title="Permalink"></a></h2><h2 id="Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion"><a class="docs-heading-anchor" href="#Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion">Attitude Control of A Space Platform / Manipulator System Using Internal Motion</a><a id="Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion-1"></a><a class="docs-heading-anchor-permalink" href="#Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion" title="Permalink"></a></h2><h2 id="Porta"><a class="docs-heading-anchor" href="#Porta">Porta</a><a id="Porta-1"></a><a class="docs-heading-anchor-permalink" href="#Porta" title="Permalink"></a></h2><h2 id="Fiber-Optic-Gyroscopes"><a class="docs-heading-anchor" href="#Fiber-Optic-Gyroscopes">Fiber Optic Gyroscopes</a><a id="Fiber-Optic-Gyroscopes-1"></a><a class="docs-heading-anchor-permalink" href="#Fiber-Optic-Gyroscopes" title="Permalink"></a></h2><h2 id="Resources"><a class="docs-heading-anchor" href="#Resources">Resources</a><a id="Resources-1"></a><a class="docs-heading-anchor-permalink" href="#Resources" title="Permalink"></a></h2><ol><li><p>Yohanes Daud, Abdullah Al Mamun and Jian-Xin Xu, <em>Dynamic modeling and characteristics analysis of lateral-pendulum unicycle robot</em>, Robotica (2017) volume 35, pp. 537–568. Cambridge University Press 2015, doi: 10.1017/S0263574715000703.</p></li><li><p>Sebastian Trimpe and Raffaello D’Andrea, <em>Accelerometer-based Tilt Estimation of a Rigid Body with only Rotational Degrees of Freedom</em>, 2010 IEEE International Conference on Robotics and Automation, Anchorage Convention District, May 3-8, 2010, Anchorage, Alaska, USA.</p></li><li><p>K. G. Vamvoudakis, D. Vrabie and F. L. Lewis, &quot;Online adaptive learning of optimal control solutions using integral reinforcement learning,&quot; 2011 IEEE Symposium on Adaptive Dynamic Programming and Reinforcement Learning (ADPRL), Paris, France, 2011, pp. 250-257, doi: 10.1109/ADPRL.2011.5967359.</p></li><li><p>Y. Engel, S. Mannor, and R. Meir, “The kernel recursive least-squares algorithm,” IEEE Transactions on Signal Processing, vol. 52, no. 8, pp. 2275–2285, 2004.</p></li><li><p>C. Fernandes, L. Gurvits and Z. X. Li, &quot;Attitude control of space platform/manipulator system using internal motion,&quot; Proceedings 1992 IEEE International Conference on Robotics and Automation, Nice, France, 1992, pp. 893-898 vol.1, doi: 10.1109/ROBOT.1992.220183.</p></li><li><p>G. C. Walsh and S. S. Sastry, &quot;On reorienting linked rigid bodies using internal motions,&quot; in IEEE Transactions on Robotics and Automation, vol. 11, no. 1, pp. 139-146, Feb. 1995, doi: 10.1109/70.345946.</p></li><li><p>Hayes, Monson H. (1996). &quot;9.4: Recursive Least Squares&quot;. Statistical Digital Signal Processing and Modeling. Wiley. p. 541. ISBN 0-471-59431-8.</p></li><li><p>Richard M. Murray, Zexiang Li, and S. Shankar Sastry, <em>A Mathematical Introduction to Robotic Manipulation</em>, CRC-Press, March 22, 1994, ISBN 9780849379819, 0849379814.</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="newsreport.html">« News Report</a><a class="docs-footer-nextpage" href="multivariablecalculus.html">Multivariable Calculus »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 9 October 2025 13:41">Thursday 9 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
