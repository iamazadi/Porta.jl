<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reaction Wheel Unicycle · Porta.jl</title><meta name="title" content="Reaction Wheel Unicycle · Porta.jl"/><meta property="og:title" content="Reaction Wheel Unicycle · Porta.jl"/><meta property="twitter:title" content="Reaction Wheel Unicycle · Porta.jl"/><meta name="description" content="How the reaction wheel unicycle works."/><meta property="og:description" content="How the reaction wheel unicycle works."/><meta property="twitter:description" content="How the reaction wheel unicycle works."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.gif" alt="Porta.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="Porta.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Porta.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="hopffibration.html">Hopf Fibration</a></li><li><a class="tocitem" href="newsreport.html">News Report</a></li><li class="is-active"><a class="tocitem" href="reactionwheelunicycle.html">Reaction Wheel Unicycle</a><ul class="internal"><li><a class="tocitem" href="#Introducing-Reinforcement-Learning-and-Feedback-Control"><span>Introducing Reinforcement Learning and Feedback Control</span></a></li><li><a class="tocitem" href="#Natural-Decision-Methods"><span>Natural Decision Methods</span></a></li><li><a class="tocitem" href="#An-Optimal-Adaptive-Controller"><span>An Optimal Adaptive Controller</span></a></li><li><a class="tocitem" href="#The-Z-Euler-Angle-Is-Not-Observable"><span>The Z-Euler Angle Is Not Observable</span></a></li><li><a class="tocitem" href="#Stepping-Through-the-Implementation"><span>Stepping Through the Implementation</span></a></li><li><a class="tocitem" href="#The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters"><span>The Convergence of Selected Algebraic Riccati Equation Solution Parameters</span></a></li><li><a class="tocitem" href="#The-Controllability-of-the-Z-Euler-Angle"><span>The Controllability of the Z-Euler Angle</span></a></li><li><a class="tocitem" href="#Nonholonomic-Motion-Planning"><span>Nonholonomic Motion Planning</span></a></li><li><a class="tocitem" href="#Steering-Using-Sinusoids"><span>Steering Using Sinusoids</span></a></li><li><a class="tocitem" href="#Steering-Second-Order-Canonical-Systems"><span>Steering Second-Order Canonical Systems</span></a></li><li><a class="tocitem" href="#Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion"><span>Attitude Control of A Space Platform / Manipulator System Using Internal Motion</span></a></li><li><a class="tocitem" href="#Porta"><span>Porta</span></a></li><li><a class="tocitem" href="#Fiber-Optic-Gyroscopes"><span>Fiber Optic Gyroscopes</span></a></li><li><a class="tocitem" href="#Resources"><span>Resources</span></a></li></ul></li><li><a class="tocitem" href="multivariablecalculus.html">Multivariable Calculus</a></li><li><a class="tocitem" href="maxwellfield_persian.html">The Maxwell Field (Persian)</a></li><li><a class="tocitem" href="reactionwheelunicycle_persian.html">The Unicycle (Persian)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reactionwheelunicycle.html">Reaction Wheel Unicycle</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reactionwheelunicycle.html">Reaction Wheel Unicycle</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/iamazadi/Porta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/iamazadi/Porta.jl/blob/master/docs/src/reactionwheelunicycle.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="How-the-Reaction-Wheel-Unicycle-Works"><a class="docs-heading-anchor" href="#How-the-Reaction-Wheel-Unicycle-Works">How the Reaction Wheel Unicycle Works</a><a id="How-the-Reaction-Wheel-Unicycle-Works-1"></a><a class="docs-heading-anchor-permalink" href="#How-the-Reaction-Wheel-Unicycle-Works" title="Permalink"></a></h1><h2 id="Introducing-Reinforcement-Learning-and-Feedback-Control"><a class="docs-heading-anchor" href="#Introducing-Reinforcement-Learning-and-Feedback-Control">Introducing Reinforcement Learning and Feedback Control</a><a id="Introducing-Reinforcement-Learning-and-Feedback-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Introducing-Reinforcement-Learning-and-Feedback-Control" title="Permalink"></a></h2><h2 id="Natural-Decision-Methods"><a class="docs-heading-anchor" href="#Natural-Decision-Methods">Natural Decision Methods</a><a id="Natural-Decision-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-Decision-Methods" title="Permalink"></a></h2><h2 id="An-Optimal-Adaptive-Controller"><a class="docs-heading-anchor" href="#An-Optimal-Adaptive-Controller">An Optimal Adaptive Controller</a><a id="An-Optimal-Adaptive-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#An-Optimal-Adaptive-Controller" title="Permalink"></a></h2><h2 id="The-Z-Euler-Angle-Is-Not-Observable"><a class="docs-heading-anchor" href="#The-Z-Euler-Angle-Is-Not-Observable">The Z-Euler Angle Is Not Observable</a><a id="The-Z-Euler-Angle-Is-Not-Observable-1"></a><a class="docs-heading-anchor-permalink" href="#The-Z-Euler-Angle-Is-Not-Observable" title="Permalink"></a></h2><h2 id="Stepping-Through-the-Implementation"><a class="docs-heading-anchor" href="#Stepping-Through-the-Implementation">Stepping Through the Implementation</a><a id="Stepping-Through-the-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Stepping-Through-the-Implementation" title="Permalink"></a></h2><p>In this section, we step through the implementation of the robot&#39;s controller in the order of execution. The controller is implemented in the C programming language. It runs on a STM32F401RE mictocontroller, which is clocked at 84 MHz. Here. we focus on the part of the code that runs in the main loop, which is a <code>while</code> loop in the main function of the program.</p><ul><li></li></ul><p>The microcontroller is built around a Cortex-M4 with Floating Point Unit (FPU) core, which contains hardware extensions for debugging features. The debug extensions allow the core to be stopped either on a given instruction fetch (breakpoint), or on data access (watchpoint). When stopped, the core&#39;s internal state and the system&#39;s external state may be examined. Once examination is complete, the core and the system may be restored and program execution resumed.</p><p>The ARM Cortex-M4 with FPU core provides integrated on-chip debug support. One of the debug features is called Data Watchpoint Trigger (DWT). The DWT unit  provides a means to give the number of clock cycles. The DWT register <code>CYCCNT</code> counts the number of clock cycles. The period of a control cycle is required in the application for integrating the gyroscopic angle rates. If we count the number of clocks twice: one time before the loop begins and one time after the loop ends, then we can find the time period that it takes to complete a control loop. In the beginning, we count the number of clocks by assigning the register value to a variable called <code>t1</code>.</p><pre><code class="language-c hljs">t1 = DWT-&gt;CYCCNT;</code></pre><ul><li></li></ul><p>There are two fuse bits on the robot for configuration without flashing a program. The first one is connected to the port C of the general purpose input / output, pin 0. The fuse bit is active whenever the connected pin is grounded. The fuse bit deactivates the linear quadratic regulator by clearing the <code>active</code> field as a flag in the model structure. Even though the status of the fuse bit 0 is necessary to activate the model, it is not a sufficient condition. The user must connect the fuse bit and also push a blue push button once on the robot for activating the model. The push button is the same blue button that is found on the NUCLEOF401RE board. These two conditions are chained together for safety reasons. If the model is not active, then the robot must stop moving. Therefore, the output of the model must be set to zero as well in order to override the last action of the model. But, the speed of a direct current motor is directly proportional to the amplitude of the enable signals of the motor driver. In the peripherals of the microcontroller, two channels of Timer 2 generate the driver enable signals. If the model is not active, then the duty cycle of the Pulse Width Modulation (PWM) of each timer channel is set to zero for safety. </p><pre><code class="language-c hljs">if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_0) == 0)
{
  if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == 0)
  {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
    model.active = 1;
  }
}
else
{
  model.active = 0;
  model.reactionPWM = 0.0;
  model.rollingPWM = 0.0;
  TIM2-&gt;CCR1 = 0;
  TIM2-&gt;CCR2 = 0;
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (fabs(model.imu1.roll) &gt; roll_safety_angle || fabs(model.imu1.pitch) &gt; pitch_safety_angle || model.k &gt; max_episode_length)
{
  model.active = 0;
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (model.active == 1)
{
  stepForward(&amp;model);
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">else
{
  model.reactionPWM = 0.0;
  model.rollingPWM = 0.0;
  TIM2-&gt;CCR1 = 0;
  TIM2-&gt;CCR2 = 0;
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);
  encodeWheel(&amp;model.reactionEncoder, TIM3-&gt;CNT);
  encodeWheel(&amp;model.rollingEncoder, TIM4-&gt;CNT);
  senseCurrent(&amp;(model.reactionCurrentSensor), &amp;(model.rollingCurrentSensor));
  updateIMU(&amp;model);
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (model.k % updatePolicyPeriod == 0)
{
  updateControlPolicy(&amp;model);
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">t2 = DWT-&gt;CYCCNT;
diff = t2 - t1;
dt = (float)diff / CPU_CLOCK;
model.dt = dt;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">log_counter++;
if (log_counter &gt; LOG_CYCLE &amp;&amp; HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_1) == 0)
{
  transmit = 1;
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (transmit == 1)
{
  transmit = 0;
  log_counter = 0;

  if (log_status == 0)
  {
    sprintf(MSG,
            &quot;AX1: %0.2f, AY1: %0.2f, AZ1: %0.2f, | AX2: %0.2f, AY2: %0.2f, AZ2: %0.2f, | roll: %0.2f, pitch: %0.2f, | encT: %0.2f, encB: %0.2f, | P0: %0.2f, P1: %0.2f, P2: %0.2f, P3: %0.2f, P4: %0.2f, dt: %0.6f\r\n&quot;,
            model.imu1.accX, model.imu1.accY, model.imu1.accZ, model.imu2.accX, model.imu2.accY, model.imu2.accZ, model.imu1.roll, model.imu1.pitch, model.reactionEncoder.radianAngle, model.rollingEncoder.radianAngle, getIndex(model.P_n, 0, 0), getIndex(model.P_n, 1, 1), getIndex(model.P_n, 2, 2), getIndex(model.P_n, 3, 3), getIndex(model.P_n, 4, 4), dt);
    log_status = 0;
  }
  HAL_UART_Transmit(&amp;huart6, MSG, sizeof(MSG), 1000);
}
// AX1: -0.05, AY1: 0.02, AZ1: 0.99, | AX2: -0.05, AY2: 0.01, AZ2: 1.01, | roll: 0.05, pitch: -0.01, | encT: 4.21, encB: 0.81, | P0: -10.02, P1: 19.02, P2: 27.25, P3: 26.37, P4: 24.57, dt: 0.006890
// Rinse and repeat :)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">/*
Identify the Q function using RLS with the given pointer to the `model`.
The algorithm is terminated when there are no further updates
to the Q function or the control policy at each step.
*/
void stepForward(LinearQuadraticRegulator *model)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">int k = model-&gt;k;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">x_k[0] = model-&gt;dataset.x0;
x_k[1] = model-&gt;dataset.x1;
x_k[2] = model-&gt;dataset.x2;
x_k[3] = model-&gt;dataset.x3;
x_k[4] = model-&gt;dataset.x4;
x_k[5] = model-&gt;dataset.x5;
x_k[6] = model-&gt;dataset.x6;
x_k[7] = model-&gt;dataset.x7;
x_k[8] = model-&gt;dataset.x8;
x_k[9] = model-&gt;dataset.x9;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">K_j[0][0] = model-&gt;K_j.x00;
K_j[0][1] = model-&gt;K_j.x01;
K_j[0][2] = model-&gt;K_j.x02;
K_j[0][3] = model-&gt;K_j.x03;
K_j[0][4] = model-&gt;K_j.x04;
K_j[0][5] = model-&gt;K_j.x05;
K_j[0][6] = model-&gt;K_j.x06;
K_j[0][7] = model-&gt;K_j.x07;
K_j[0][8] = model-&gt;K_j.x08;
K_j[0][9] = model-&gt;K_j.x09;
K_j[1][0] = model-&gt;K_j.x10;
K_j[1][1] = model-&gt;K_j.x11;
K_j[1][2] = model-&gt;K_j.x12;
K_j[1][3] = model-&gt;K_j.x13;
K_j[1][4] = model-&gt;K_j.x14;
K_j[1][5] = model-&gt;K_j.x15;
K_j[1][6] = model-&gt;K_j.x16;
K_j[1][7] = model-&gt;K_j.x17;
K_j[1][8] = model-&gt;K_j.x18;
K_j[1][9] = model-&gt;K_j.x19;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">u_k[0] = 0.0;
u_k[1] = 0.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// feeback policy
for (int i = 0; i &lt; model-&gt;m; i++)
{
  for (int j = 0; j &lt; model-&gt;n; j++)
  {
    u_k[i] += -K_j[i][j] * x_k[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;dataset.x0 = model-&gt;imu1.roll / M_PI;
model-&gt;dataset.x1 = model-&gt;imu1.roll_velocity / M_PI;
model-&gt;dataset.x2 = model-&gt;imu1.roll_acceleration / M_PI;
model-&gt;dataset.x3 = model-&gt;imu1.pitch / M_PI;
model-&gt;dataset.x4 = model-&gt;imu1.pitch_velocity / M_PI;
model-&gt;dataset.x5 = model-&gt;imu1.pitch_acceleration / M_PI;
model-&gt;dataset.x6 = model-&gt;reactionEncoder.velocity;
model-&gt;dataset.x7 = model-&gt;rollingEncoder.velocity;
model-&gt;dataset.x8 = model-&gt;reactionCurrentSensor.currentVelocity;
model-&gt;dataset.x9 = model-&gt;rollingCurrentSensor.currentVelocity;
model-&gt;dataset.x10 = u_k[0];
model-&gt;dataset.x11 = u_k[1];</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;reactionPWM += (255.0 * pulseStep) * u_k[0];
model-&gt;rollingPWM += (255.0 * pulseStep) * u_k[1];
model-&gt;reactionPWM = fmin(255.0 * 255.0, model-&gt;reactionPWM);
model-&gt;reactionPWM = fmax(-255.0 * 255.0, model-&gt;reactionPWM);
model-&gt;rollingPWM = fmin(255.0 * 255.0, model-&gt;rollingPWM);
model-&gt;rollingPWM = fmax(-255.0 * 255.0, model-&gt;rollingPWM);
TIM2-&gt;CCR1 = (int)fabs(model-&gt;rollingPWM);
TIM2-&gt;CCR2 = (int)fabs(model-&gt;reactionPWM);
if (model-&gt;reactionPWM &lt; 0)
{
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_SET);
}
else
{
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_SET);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
}
if (model-&gt;rollingPWM &lt; 0)
{
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET);
}
else
{
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">else
{
  model-&gt;reactionPWM = 0.0;
  model-&gt;rollingPWM = 0.0;
  TIM2-&gt;CCR1 = 0;
  TIM2-&gt;CCR2 = 0;
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">encodeWheel(&amp;(model-&gt;reactionEncoder), TIM3-&gt;CNT);
encodeWheel(&amp;(model-&gt;rollingEncoder), TIM4-&gt;CNT);
senseCurrent(&amp;(model-&gt;reactionCurrentSensor), &amp;(model-&gt;rollingCurrentSensor));
updateIMU(model);</code></pre><ul><li></li></ul><pre><code class="nohighlight hljs">// dataset = (xₖ, uₖ, xₖ₊₁, uₖ₊₁)
model-&gt;dataset.x12 = model-&gt;imu1.roll / M_PI;
model-&gt;dataset.x13 = model-&gt;imu1.roll_velocity / M_PI;
model-&gt;dataset.x14 = model-&gt;imu1.roll_acceleration / M_PI;
model-&gt;dataset.x15 = model-&gt;imu1.pitch / M_PI;
model-&gt;dataset.x16 = model-&gt;imu1.pitch_velocity / M_PI;
model-&gt;dataset.x17 = model-&gt;imu1.pitch_acceleration / M_PI;
model-&gt;dataset.x18 = model-&gt;reactionEncoder.velocity;
model-&gt;dataset.x19 = model-&gt;rollingEncoder.velocity;
model-&gt;dataset.x20 = model-&gt;reactionCurrentSensor.currentVelocity;
model-&gt;dataset.x21 = model-&gt;rollingCurrentSensor.currentVelocity;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">x_k1[0] = model-&gt;dataset.x12;
x_k1[1] = model-&gt;dataset.x13;
x_k1[2] = model-&gt;dataset.x14;
x_k1[3] = model-&gt;dataset.x15;
x_k1[4] = model-&gt;dataset.x16;
x_k1[5] = model-&gt;dataset.x17;
x_k1[6] = model-&gt;dataset.x18;
x_k1[7] = model-&gt;dataset.x19;
x_k1[8] = model-&gt;dataset.x20;
x_k1[9] = model-&gt;dataset.x21;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">u_k1[0] = 0.0;
u_k1[1] = 0.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; model-&gt;m; i++)
{
  for (int j = 0; j &lt; model-&gt;n; j++)
  {
    u_k1[i] += -K_j[i][j] * x_k1[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;dataset.x22 = u_k1[0];
model-&gt;dataset.x23 = u_k1[1];</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Compute the quadratic basis sets ϕ(zₖ), ϕ(zₖ₊₁).
z_k[0] = model-&gt;dataset.x0;
z_k[1] = model-&gt;dataset.x1;
z_k[2] = model-&gt;dataset.x2;
z_k[3] = model-&gt;dataset.x3;
z_k[4] = model-&gt;dataset.x4;
z_k[5] = model-&gt;dataset.x5;
z_k[6] = model-&gt;dataset.x6;
z_k[7] = model-&gt;dataset.x7;
z_k[8] = model-&gt;dataset.x8;
z_k[9] = model-&gt;dataset.x9;
z_k[10] = model-&gt;dataset.x10;
z_k[11] = model-&gt;dataset.x11;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">z_k1[0] = model-&gt;dataset.x12;
z_k1[1] = model-&gt;dataset.x13;
z_k1[2] = model-&gt;dataset.x14;
z_k1[3] = model-&gt;dataset.x15;
z_k1[4] = model-&gt;dataset.x16;
z_k1[5] = model-&gt;dataset.x17;
z_k1[6] = model-&gt;dataset.x18;
z_k1[7] = model-&gt;dataset.x19;
z_k1[8] = model-&gt;dataset.x20;
z_k1[9] = model-&gt;dataset.x21;
z_k1[10] = model-&gt;dataset.x22;
z_k1[11] = model-&gt;dataset.x23;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  basisset0[i] = z_k[i];
  basisset1[i] = z_k1[i];
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Now perform a one-step update in the parameter vector W by applying RLS to equation (S27).
// initialize z_n
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  z_n[i] = 0.0;
}
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
  {
    z_n[i] += getIndex(model-&gt;P_n, i, j) * z_k[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">z_k1_dot_z_n = 0.0;
float buffer = 0.0;
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  buffer = z_k1[i] * z_n[i];
  if (isnanf(buffer) == 0)
  {
    z_k1_dot_z_n += buffer;
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (fabs(model-&gt;lambda + z_k1_dot_z_n) &gt; 0)
{
  for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
  {
    g_n[i] = (1.0 / (model-&gt;lambda + z_k1_dot_z_n)) * z_n[i];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">else
{
  for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
  {
    g_n[i] = (1.0 / model-&gt;lambda) * z_n[i];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// αₙ = dₙ - transpose(wₙ₋₁) * xₙ
// initialize alpha_n
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  alpha_n[i] = 0.0;
}
for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
  {
    alpha_n[i] += getIndex(model-&gt;W_n, i, j) * (basisset1[j] - basisset0[j]); // checked manually
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
  {
    buffer = getIndex(model-&gt;W_n, i, j) + (alpha_n[i] * g_n[j]);
    if (isnanf(buffer) == 0)
    {
      setIndex(&amp;(model-&gt;W_n), i, j, buffer); // checked manually
    }
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; (model-&gt;n + model-&gt;m); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;m); j++)
  {
    buffer = (1.0 / model-&gt;lambda) * (getIndex(model-&gt;P_n, i, j) - g_n[i] * z_n[j]);
    if (isnanf(buffer) == 0)
    {
      setIndex(&amp;(model-&gt;P_n), i, j, buffer); // checked manually
    }
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Repeat at the next time k + 1 and continue until RLS converges and the new parameter vector Wⱼ₊₁ is found.
model-&gt;k = k + 1;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">typedef struct
{
  float row0[N + M];
  float row1[N + M];
  float row2[N + M];
  float row3[N + M];
  float row4[N + M];
  float row5[N + M];
  float row6[N + M];
  float row7[N + M];
  float row8[N + M];
  float row9[N + M];
  float row10[N + M];
  float row11[N + M];
} Mat12;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float getIndex(Mat12 matrix, int i, int j)
void setIndex(Mat12 *matrix, int i, int j, float value)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void updateControlPolicy(LinearQuadraticRegulator *model)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// unpack the vector Wⱼ₊₁ into the kernel matrix
// Q(xₖ, uₖ) ≡ 0.5 * transpose([xₖ; uₖ]) * S * [xₖ; uₖ] = 0.5 * transpose([xₖ; uₖ]) * [Sₓₓ Sₓᵤ; Sᵤₓ Sᵤᵤ] * [xₖ; uₖ]
model-&gt;k = 1;
model-&gt;j = model-&gt;j + 1;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// initialize the filter matrix
// putBuffer(model-&gt;m + model-&gt;n, model-&gt;m + model-&gt;n, W_n, model-&gt;W_n);

for (int i = 0; i &lt; model-&gt;m; i++)
{
  for (int j = 0; j &lt; model-&gt;n; j++)
  {
    S_ux[i][j] = getIndex(model-&gt;W_n, model-&gt;n + i, j);
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; model-&gt;m; i++)
{
  for (int j = 0; j &lt; model-&gt;m; j++)
  {
    S_uu[i][j] = getIndex(model-&gt;W_n, model-&gt;n + i, model-&gt;n + j);
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Perform the control update using (S24), which is uₖ = -S⁻¹ᵤᵤ * Sᵤₓ * xₖ
// uₖ = -S⁻¹ᵤᵤ * Sᵤₓ * xₖ
float determinant = S_uu[1][1] * S_uu[2][2] - S_uu[1][2] * S_uu[2][1];
// check the rank of S_uu to see if it&#39;s equal to 2 (invertible matrix)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (fabs(determinant) &gt; 0.0001) // greater than zero
{
  S_uu_inverse[0][0] = S_uu[1][1] / determinant;
  S_uu_inverse[0][1] = -S_uu[0][1] / determinant;
  S_uu_inverse[1][0] = -S_uu[1][0] / determinant;
  S_uu_inverse[1][1] = S_uu[0][0] / determinant;
  // initialize the gain matrix
  for (int i = 0; i &lt; model-&gt;m; i++)
  {
    for (int j = 0; j &lt; model-&gt;n; j++)
    {
      K_j[i][j] = 0.0;
    }
  }
  for (int i = 0; i &lt; model-&gt;m; i++)
  {
    for (int j = 0; j &lt; model-&gt;n; j++)
    {
      for (int k = 0; k &lt; model-&gt;m; k++)
      {
        K_j[i][j] += S_uu_inverse[i][k] * S_ux[k][j];
      }
    }
  }
  model-&gt;K_j.x00 = K_j[0][0];
  model-&gt;K_j.x01 = K_j[0][1];
  model-&gt;K_j.x02 = K_j[0][2];
  model-&gt;K_j.x03 = K_j[0][3];
  model-&gt;K_j.x04 = K_j[0][4];
  model-&gt;K_j.x05 = K_j[0][5];
  model-&gt;K_j.x06 = K_j[0][6];
  model-&gt;K_j.x07 = K_j[0][7];
  model-&gt;K_j.x08 = K_j[0][8];
  model-&gt;K_j.x09 = K_j[0][9];
  model-&gt;K_j.x10 = K_j[1][0];
  model-&gt;K_j.x11 = K_j[1][1];
  model-&gt;K_j.x12 = K_j[1][2];
  model-&gt;K_j.x13 = K_j[1][3];
  model-&gt;K_j.x14 = K_j[1][4];
  model-&gt;K_j.x15 = K_j[1][5];
  model-&gt;K_j.x16 = K_j[1][6];
  model-&gt;K_j.x17 = K_j[1][7];
  model-&gt;K_j.x18 = K_j[1][8];
  model-&gt;K_j.x19 = K_j[1][9];
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// instantiate a model and initialize it
LinearQuadraticRegulator model;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Represents a Linear Quadratic Regulator (LQR) model.
typedef struct
{
  Mat12 W_n;                           // filter matrix
  Mat12 P_n;                           // inverse autocorrelation matrix
  Mat210f K_j;                         // feedback policy
  Vec24f dataset;                      // (xₖ, uₖ, xₖ₊₁, uₖ₊₁)
  int j;                               // step number
  int k;                               // time k
  int n;                               // xₖ ∈ ℝⁿ
  int m;                               // uₖ ∈ ℝᵐ
  float lambda;                        // exponential wighting factor
  float delta;                         // value used to intialize P(0)
  int active;                          // is the model controller active
  float dt;                            // period in seconds
  float reactionPWM;                   // reaction wheel&#39;s motor PWM duty cycle
  float rollingPWM;                    // rolling wheel&#39;s motor PWM duty cycle
  IMU imu1;                            // the first inertial measurement unit
  IMU imu2;                            // the second inertial measurement unit
  Encoder reactionEncoder;             // the reaction wheel encoder
  Encoder rollingEncoder;              // the rolling wheel encoder
  CurrentSensor reactionCurrentSensor; // the reaction wheel&#39;s motor current sensor
  CurrentSensor rollingCurrentSensor;  // the rolling wheel&#39;s motor current sensor
} LinearQuadraticRegulator;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void updateIMU(LinearQuadraticRegulator *model)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">updateIMU1(&amp;(model-&gt;imu1));
updateIMU2(&amp;(model-&gt;imu2));</code></pre><ul><li></li></ul><pre><code class="language-c hljs">typedef struct
{
  int16_t accX_offset;
  int16_t accY_offset;
  int16_t accZ_offset;
  float accX_scale;
  float accY_scale;
  float accZ_scale;
  int16_t gyrX_offset;
  int16_t gyrY_offset;
  int16_t gyrZ_offset;
  float gyrX_scale;
  float gyrY_scale;
  float gyrZ_scale;
  int16_t rawAccX;
  int16_t rawAccY;
  int16_t rawAccZ;
  int16_t rawGyrX;
  int16_t rawGyrY;
  int16_t rawGyrZ;
  float accX;
  float accY;
  float accZ;
  float gyrX;
  float gyrY;
  float gyrZ;
  float roll;
  float pitch;
  float yaw;
  float roll_velocity;
  float pitch_velocity;
  float yaw_velocity;
  float roll_acceleration;
  float pitch_acceleration;
  float yaw_acceleration;
} IMU;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">R1[0] = model-&gt;imu1.accX;
R1[1] = model-&gt;imu1.accY;
R1[2] = model-&gt;imu1.accZ;
R2[0] = model-&gt;imu2.accX;
R2[1] = model-&gt;imu2.accY;
R2[2] = model-&gt;imu2.accZ;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">_R1[0] = 0.0;
_R1[1] = 0.0;
_R1[2] = 0.0;
_R2[0] = 0.0;
_R2[1] = 0.0;
_R2[2] = 0.0;
for (int i = 0; i &lt; 3; i++)
{
  for (int j = 0; j &lt; 3; j++)
  {
    _R1[i] += B_A1_R[i][j] * R1[j];
    _R2[i] += B_A2_R[i][j] * R2[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; 3; i++)
{
  Matrix[i][0] = _R1[i];
  Matrix[i][1] = _R2[i];
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; 3; i++)
{
  for (int j = 0; j &lt; 4; j++)
  {
    Q[i][j] = 0.0;
    for (int k = 0; k &lt; 2; k++)
    {
      Q[i][j] += Matrix[i][k] * X[k][j];
    }
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">g[0] = Q[0][0];
g[1] = Q[1][0];
g[2] = Q[2][0];</code></pre><ul><li></li></ul><pre><code class="language-c hljs">beta = atan2(-g[0], sqrt(pow(g[1], 2) + pow(g[2], 2)));</code></pre><ul><li></li></ul><pre><code class="language-c hljs">gamma1 = atan2(g[1], g[2]);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">G1[0] = model-&gt;imu1.gyrX;
G1[1] = model-&gt;imu1.gyrY;
G1[2] = model-&gt;imu1.gyrZ;
G2[0] = model-&gt;imu2.gyrX;
G2[1] = model-&gt;imu2.gyrY;
G2[2] = model-&gt;imu2.gyrZ;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">_G1[0] = 0.0;
_G1[1] = 0.0;
_G1[2] = 0.0;
_G2[0] = 0.0;
_G2[1] = 0.0;
_G2[2] = 0.0;
for (int i = 0; i &lt; 3; i++)
{
  for (int j = 0; j &lt; 3; j++)
  {
    _G1[i] += B_A1_R[i][j] * G1[j];
    _G2[i] += B_A2_R[i][j] * G2[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; 3; i++)
{
  r[i] = (_G1[i] + _G2[i]) / 2.0;
}</code></pre><ul><li></li></ul><pre><code class="nohighlight hljs">E[0][0] = 0.0;
E[0][1] = sin(gamma1) / cos(beta);
E[0][2] = cos(gamma1) / cos(beta);
E[1][0] = 0.0;
E[1][1] = cos(gamma1);
E[1][2] = -sin(gamma1);
E[2][0] = 1.0;
E[2][1] = sin(gamma1) * tan(beta);
E[2][2] = cos(gamma1) * tan(beta);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">r_dot[0] = 0.0;
r_dot[1] = 0.0;
r_dot[2] = 0.0;
for (int i = 0; i &lt; 3; i++)
{
  for (int j = 0; j &lt; 3; j++)
  {
    r_dot[i] += E[i][j] * r[j];
    r_dot[i] += E[i][j] * r[j];
    r_dot[i] += E[i][j] * r[j];
    r_dot[i] += E[i][j] * r[j];
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">fused_beta = kappa1 * beta + (1.0 - kappa1) * (fused_beta + model-&gt;dt * (r_dot[1] / 180.0 * M_PI));</code></pre><ul><li></li></ul><pre><code class="language-c hljs">fused_gamma = kappa2 * gamma1 + (1.0 - kappa2) * (fused_gamma + model-&gt;dt * (r_dot[2] / 180.0 * M_PI));</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float _roll = fused_beta;
float _pitch = -fused_gamma;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float _roll_velocity = ((r_dot[1] / 180.0 * M_PI) + (_roll - model-&gt;imu1.roll) / model-&gt;dt) / 2.0;
float _pitch_velocity = ((-r_dot[2] / 180.0 * M_PI) + (_pitch - model-&gt;imu1.pitch) / model-&gt;dt) / 2.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;imu1.roll_acceleration = _roll_velocity - model-&gt;imu1.roll_velocity;
model-&gt;imu1.pitch_acceleration = _pitch_velocity - model-&gt;imu1.pitch_velocity;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;imu1.roll_velocity = _roll_velocity;
model-&gt;imu1.pitch_velocity = _pitch_velocity;
model-&gt;imu1.roll = _roll;
model-&gt;imu1.pitch = _pitch;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">typedef struct
{
  int pulse_per_revolution; // the number of pulses per revolution
  int value;                // the counter
  float radianAngle;        // the angle in radian
  float angle;              // the absolute angle
  float velocity;           // the angular velocity
  float acceleration;       // the angular acceleration
} Encoder;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void encodeWheel(Encoder *encoder, int newValue)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">encoder-&gt;value = newValue;
encoder-&gt;radianAngle = (float)(encoder-&gt;value % encoder-&gt;pulse_per_revolution) / (float)encoder-&gt;pulse_per_revolution * 2.0 * M_PI;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float angle = sin(encoder-&gt;radianAngle);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float velocity = angle - encoder-&gt;angle;
float acceleration = velocity - encoder-&gt;velocity;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">encoder-&gt;angle = angle;
encoder-&gt;velocity = velocity;
encoder-&gt;acceleration = acceleration;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">typedef struct
{
  float currentScale;
  int current0;
  int current1;
  float currentVelocity;
} CurrentSensor;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void senseCurrent(CurrentSensor *reactionCurrentSensor, CurrentSensor *rollingCurrentSensor)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Start ADC Conversion in DMA Mode (Periodically Every 1ms)
HAL_ADC_Start_DMA(&amp;hadc1, AD_RES_BUFFER, 2);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">reactionCurrentSensor-&gt;current1 = reactionCurrentSensor-&gt;current0;
rollingCurrentSensor-&gt;current1 = rollingCurrentSensor-&gt;current0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">reactionCurrentSensor-&gt;current0 = (AD_RES_BUFFER[0] &lt;&lt; 4);
rollingCurrentSensor-&gt;current0 = (AD_RES_BUFFER[1] &lt;&lt; 4);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">reactionCurrentSensor-&gt;currentVelocity = (float)(reactionCurrentSensor-&gt;current0 - reactionCurrentSensor-&gt;current1) / reactionCurrentSensor-&gt;currentScale;
rollingCurrentSensor-&gt;currentVelocity = (float)(rollingCurrentSensor-&gt;current0 - rollingCurrentSensor-&gt;current1) / rollingCurrentSensor-&gt;currentScale;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void updateIMU1(IMU *sensor) // GY-25 I2C</code></pre><ul><li></li></ul><pre><code class="language-c hljs">do
{
  HAL_I2C_Master_Transmit(&amp;hi2c1, (uint16_t)SLAVE_ADDRESS, (uint8_t *)&amp;transferRequest, 1, 10);
  while (HAL_I2C_GetState(&amp;hi2c1) != HAL_I2C_STATE_READY)
    ;
} while (HAL_I2C_GetError(&amp;hi2c1) == HAL_I2C_ERROR_AF);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">do
{
  HAL_I2C_Master_Receive(&amp;hi2c1, (uint16_t)SLAVE_ADDRESS, (uint8_t *)raw_data, 12, 10);
  while (HAL_I2C_GetState(&amp;hi2c1) != HAL_I2C_STATE_READY)
    ;
  sensor-&gt;rawAccX = (raw_data[0] &lt;&lt; 8) | raw_data[1];
  sensor-&gt;rawAccY = (raw_data[2] &lt;&lt; 8) | raw_data[3];
  sensor-&gt;rawAccZ = (raw_data[4] &lt;&lt; 8) | raw_data[5];
  sensor-&gt;rawGyrX = (raw_data[6] &lt;&lt; 8) | raw_data[7];
  sensor-&gt;rawGyrY = (raw_data[8] &lt;&lt; 8) | raw_data[9];
  sensor-&gt;rawGyrZ = (raw_data[10] &lt;&lt; 8) | raw_data[11];
  sensor-&gt;accX = sensor-&gt;accX_scale * (sensor-&gt;rawAccX - sensor-&gt;accX_offset);
  sensor-&gt;accY = sensor-&gt;accY_scale * (sensor-&gt;rawAccY - sensor-&gt;accY_offset);
  sensor-&gt;accZ = sensor-&gt;accZ_scale * (sensor-&gt;rawAccZ - sensor-&gt;accZ_offset);
  sensor-&gt;gyrX = sensor-&gt;gyrX_scale * (sensor-&gt;rawGyrX - sensor-&gt;gyrX_offset);
  sensor-&gt;gyrY = sensor-&gt;gyrY_scale * (sensor-&gt;rawGyrY - sensor-&gt;gyrY_offset);
  sensor-&gt;gyrZ = sensor-&gt;gyrZ_scale * (sensor-&gt;rawGyrZ - sensor-&gt;gyrZ_offset);
} while (HAL_I2C_GetError(&amp;hi2c1) == HAL_I2C_ERROR_AF);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void updateIMU2(IMU *sensor) // GY-95 USART</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (uart_receive_ok == 1)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">if (UART1_rxBuffer[0] == UART1_txBuffer[0] &amp;&amp; UART1_rxBuffer[1] == UART1_txBuffer[1] &amp;&amp; UART1_rxBuffer[2] == UART1_txBuffer[2] &amp;&amp; UART1_rxBuffer[3] == UART1_txBuffer[3])</code></pre><ul><li></li></ul><pre><code class="language-c hljs">sensor-&gt;rawAccX = (UART1_rxBuffer[5] &lt;&lt; 8) | UART1_rxBuffer[4];
sensor-&gt;rawAccY = (UART1_rxBuffer[7] &lt;&lt; 8) | UART1_rxBuffer[6];
sensor-&gt;rawAccZ = (UART1_rxBuffer[9] &lt;&lt; 8) | UART1_rxBuffer[8];
sensor-&gt;rawGyrX = (UART1_rxBuffer[11] &lt;&lt; 8) | UART1_rxBuffer[10];
sensor-&gt;rawGyrY = (UART1_rxBuffer[13] &lt;&lt; 8) | UART1_rxBuffer[12];
sensor-&gt;rawGyrZ = (UART1_rxBuffer[15] &lt;&lt; 8) | UART1_rxBuffer[14];</code></pre><ul><li></li></ul><pre><code class="language-c hljs">sensor-&gt;accX = sensor-&gt;accX_scale * (sensor-&gt;rawAccX - sensor-&gt;accX_offset);
sensor-&gt;accY = sensor-&gt;accY_scale * (sensor-&gt;rawAccY - sensor-&gt;accY_offset);
sensor-&gt;accZ = sensor-&gt;accZ_scale * (sensor-&gt;rawAccZ - sensor-&gt;accZ_offset);
sensor-&gt;gyrX = sensor-&gt;gyrX_scale * (sensor-&gt;rawGyrX - sensor-&gt;gyrX_offset);
sensor-&gt;gyrY = sensor-&gt;gyrY_scale * (sensor-&gt;rawGyrY - sensor-&gt;gyrY_offset);
sensor-&gt;gyrZ = sensor-&gt;gyrZ_scale * (sensor-&gt;rawGyrZ - sensor-&gt;gyrZ_offset);</code></pre><ul><li></li></ul><pre><code class="language-c hljs">float dummyx = cos(sensorAngle) * sensor-&gt;accX - sin(sensorAngle) * sensor-&gt;accY;
float dummyy = sin(sensorAngle) * sensor-&gt;accX + cos(sensorAngle) * sensor-&gt;accY;
sensor-&gt;accX = -dummyy;
sensor-&gt;accY = dummyx;
dummyx = cos(sensorAngle) * sensor-&gt;gyrX - sin(sensorAngle) * sensor-&gt;gyrY;
dummyy = sin(sensorAngle) * sensor-&gt;gyrX + cos(sensorAngle) * sensor-&gt;gyrY;
sensor-&gt;gyrX = -dummyy;
sensor-&gt;gyrY = dummyx;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">uart_receive_ok = 0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (uart_receive_ok == 0 &amp;&amp; huart-&gt;Instance == USART1)
  {
    uart_receive_ok = 1;
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// Initialize the randomizer using the current timestamp as a seed
// (The time() function is provided by the &lt;time.h&gt; header file)
// srand(time(NULL));
void initialize(LinearQuadraticRegulator *model)</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;j = 1;
model-&gt;k = 1;
model-&gt;n = dim_n;
model-&gt;m = dim_m;
model-&gt;lambda = 0.99;
model-&gt;delta = 0.01;
model-&gt;active = 0;
model-&gt;dt = 0.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">for (int i = 0; i &lt; (model-&gt;n + model-&gt;n); i++)
{
  for (int j = 0; j &lt; (model-&gt;n + model-&gt;n); j++)
  {
    setIndex(&amp;(model-&gt;W_n), i, j, (float)(rand() % 100) / 100.0);
    if (i == j)
    {
      setIndex(&amp;(model-&gt;P_n), i, j, 1.0);
    }
    else
    {
      setIndex(&amp;(model-&gt;P_n), i, j, 0.0);
    }
  }
}</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;K_j.x00 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x01 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x02 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x03 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x04 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x05 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x06 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x07 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x08 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x09 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x10 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x11 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x12 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x13 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x14 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x15 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x16 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x17 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x18 = (float)(rand() % 100) / 100.0;
model-&gt;K_j.x19 = (float)(rand() % 100) / 100.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;dataset.x0 = 0.0;
model-&gt;dataset.x1 = 0.0;
model-&gt;dataset.x2 = 0.0;
model-&gt;dataset.x3 = 0.0;
model-&gt;dataset.x4 = 0.0;
model-&gt;dataset.x5 = 0.0;
model-&gt;dataset.x6 = 0.0;
model-&gt;dataset.x7 = 0.0;
model-&gt;dataset.x8 = 0.0;
model-&gt;dataset.x9 = 0.0;
model-&gt;dataset.x10 = 0.0;
model-&gt;dataset.x11 = 0.0;
model-&gt;dataset.x12 = 0.0;
model-&gt;dataset.x13 = 0.0;
model-&gt;dataset.x14 = 0.0;
model-&gt;dataset.x15 = 0.0;
model-&gt;dataset.x16 = 0.0;
model-&gt;dataset.x17 = 0.0;
model-&gt;dataset.x18 = 0.0;
model-&gt;dataset.x19 = 0.0;
model-&gt;dataset.x20 = 0.0;
model-&gt;dataset.x21 = 0.0;
model-&gt;dataset.x22 = 0.0;
model-&gt;dataset.x23 = 0.0;</code></pre><ul><li></li></ul><pre><code class="language-c hljs">// scale : 1 / 2048
IMU imu1 = {-24, -60, 27, 0.000488281, 0.000488281, 0.000488281, 0, 0, 0, 0.017444444, 0.017444444, 0.017444444, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
IMU imu2 = {75, -25, -18, 0.000488281, 0.000488281, 0.000488281, 0, 0, 0, 0.017444444, 0.017444444, 0.017444444, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};</code></pre><ul><li></li></ul><pre><code class="language-c hljs">Encoder reactionEncoder = {1736, 0, 0, 0, 0, 0};
Encoder rollingEncoder = {3020, 0, 0, 0, 0, 0};</code></pre><ul><li></li></ul><pre><code class="language-c hljs">CurrentSensor reactionCurrentSensor = {32000.0, 0, 0, 0};
CurrentSensor rollingCurrentSensor = {32000.0, 0, 0, 0};</code></pre><ul><li></li></ul><pre><code class="language-c hljs">model-&gt;imu1 = imu1;
model-&gt;imu2 = imu2;
model-&gt;reactionEncoder = reactionEncoder;
model-&gt;rollingEncoder = rollingEncoder;
model-&gt;reactionCurrentSensor = reactionCurrentSensor;
model-&gt;rollingCurrentSensor = rollingCurrentSensor;
model-&gt;reactionPWM = 0.0;
model-&gt;rollingPWM = 0.0;</code></pre><h2 id="The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters"><a class="docs-heading-anchor" href="#The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters">The Convergence of Selected Algebraic Riccati Equation Solution Parameters</a><a id="The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#The-Convergence-of-Selected-Algebraic-Riccati-Equation-Solution-Parameters" title="Permalink"></a></h2><h2 id="The-Controllability-of-the-Z-Euler-Angle"><a class="docs-heading-anchor" href="#The-Controllability-of-the-Z-Euler-Angle">The Controllability of the Z-Euler Angle</a><a id="The-Controllability-of-the-Z-Euler-Angle-1"></a><a class="docs-heading-anchor-permalink" href="#The-Controllability-of-the-Z-Euler-Angle" title="Permalink"></a></h2><h2 id="Nonholonomic-Motion-Planning"><a class="docs-heading-anchor" href="#Nonholonomic-Motion-Planning">Nonholonomic Motion Planning</a><a id="Nonholonomic-Motion-Planning-1"></a><a class="docs-heading-anchor-permalink" href="#Nonholonomic-Motion-Planning" title="Permalink"></a></h2><h2 id="Steering-Using-Sinusoids"><a class="docs-heading-anchor" href="#Steering-Using-Sinusoids">Steering Using Sinusoids</a><a id="Steering-Using-Sinusoids-1"></a><a class="docs-heading-anchor-permalink" href="#Steering-Using-Sinusoids" title="Permalink"></a></h2><h2 id="Steering-Second-Order-Canonical-Systems"><a class="docs-heading-anchor" href="#Steering-Second-Order-Canonical-Systems">Steering Second-Order Canonical Systems</a><a id="Steering-Second-Order-Canonical-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Steering-Second-Order-Canonical-Systems" title="Permalink"></a></h2><h2 id="Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion"><a class="docs-heading-anchor" href="#Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion">Attitude Control of A Space Platform / Manipulator System Using Internal Motion</a><a id="Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion-1"></a><a class="docs-heading-anchor-permalink" href="#Attitude-Control-of-A-Space-Platform-/-Manipulator-System-Using-Internal-Motion" title="Permalink"></a></h2><h2 id="Porta"><a class="docs-heading-anchor" href="#Porta">Porta</a><a id="Porta-1"></a><a class="docs-heading-anchor-permalink" href="#Porta" title="Permalink"></a></h2><h2 id="Fiber-Optic-Gyroscopes"><a class="docs-heading-anchor" href="#Fiber-Optic-Gyroscopes">Fiber Optic Gyroscopes</a><a id="Fiber-Optic-Gyroscopes-1"></a><a class="docs-heading-anchor-permalink" href="#Fiber-Optic-Gyroscopes" title="Permalink"></a></h2><h2 id="Resources"><a class="docs-heading-anchor" href="#Resources">Resources</a><a id="Resources-1"></a><a class="docs-heading-anchor-permalink" href="#Resources" title="Permalink"></a></h2><ol><li><p>Yohanes Daud, Abdullah Al Mamun and Jian-Xin Xu, <em>Dynamic modeling and characteristics analysis of lateral-pendulum unicycle robot</em>, Robotica (2017) volume 35, pp. 537–568. Cambridge University Press 2015, doi: 10.1017/S0263574715000703.</p></li><li><p>Sebastian Trimpe and Raffaello D’Andrea, <em>Accelerometer-based Tilt Estimation of a Rigid Body with only Rotational Degrees of Freedom</em>, 2010 IEEE International Conference on Robotics and Automation, Anchorage Convention District, May 3-8, 2010, Anchorage, Alaska, USA.</p></li><li><p>K. G. Vamvoudakis, D. Vrabie and F. L. Lewis, &quot;Online adaptive learning of optimal control solutions using integral reinforcement learning,&quot; 2011 IEEE Symposium on Adaptive Dynamic Programming and Reinforcement Learning (ADPRL), Paris, France, 2011, pp. 250-257, doi: 10.1109/ADPRL.2011.5967359.</p></li><li><p>Y. Engel, S. Mannor, and R. Meir, “The kernel recursive least-squares algorithm,” IEEE Transactions on Signal Processing, vol. 52, no. 8, pp. 2275–2285, 2004.</p></li><li><p>C. Fernandes, L. Gurvits and Z. X. Li, &quot;Attitude control of space platform/manipulator system using internal motion,&quot; Proceedings 1992 IEEE International Conference on Robotics and Automation, Nice, France, 1992, pp. 893-898 vol.1, doi: 10.1109/ROBOT.1992.220183.</p></li><li><p>G. C. Walsh and S. S. Sastry, &quot;On reorienting linked rigid bodies using internal motions,&quot; in IEEE Transactions on Robotics and Automation, vol. 11, no. 1, pp. 139-146, Feb. 1995, doi: 10.1109/70.345946.</p></li><li><p>Hayes, Monson H. (1996). &quot;9.4: Recursive Least Squares&quot;. Statistical Digital Signal Processing and Modeling. Wiley. p. 541. ISBN 0-471-59431-8.</p></li><li><p>Richard M. Murray, Zexiang Li, and S. Shankar Sastry, <em>A Mathematical Introduction to Robotic Manipulation</em>, CRC-Press, March 22, 1994, ISBN 9780849379819, 0849379814.</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="newsreport.html">« News Report</a><a class="docs-footer-nextpage" href="multivariablecalculus.html">Multivariable Calculus »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 25 September 2025 14:17">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
