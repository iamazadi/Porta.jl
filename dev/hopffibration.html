<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hopf Fibration · Porta.jl</title><meta name="title" content="Hopf Fibration · Porta.jl"/><meta property="og:title" content="Hopf Fibration · Porta.jl"/><meta property="twitter:title" content="Hopf Fibration · Porta.jl"/><meta name="description" content="How the Hopf fibration works."/><meta property="og:description" content="How the Hopf fibration works."/><meta property="twitter:description" content="How the Hopf fibration works."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.gif" alt="Porta.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="Porta.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Porta.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="hopffibration.html">Hopf Fibration</a><ul class="internal"><li><a class="tocitem" href="#Import-the-Required-Packages"><span>Import the Required Packages</span></a></li><li><a class="tocitem" href="#Set-Hyperparameters"><span>Set Hyperparameters</span></a></li><li><a class="tocitem" href="#Load-the-Natural-Earth-Data"><span>Load the Natural Earth Data</span></a></li><li><a class="tocitem" href="#Make-a-Computer-Graphical-Scene"><span>Make a Computer Graphical Scene</span></a></li><li><a class="tocitem" href="#Construct-Base-Maps"><span>Construct Base Maps</span></a></li><li><a class="tocitem" href="#Construct-Whirls"><span>Construct Whirls</span></a></li><li><a class="tocitem" href="#Compute-a-Four-Screw"><span>Compute a Four-Screw</span></a></li><li><a class="tocitem" href="#Compute-a-Null-Rotation"><span>Compute a Null Rotation</span></a></li><li><a class="tocitem" href="#Update-the-Camera"><span>Update the Camera</span></a></li><li><a class="tocitem" href="#Record-an-Animation"><span>Record an Animation</span></a></li></ul></li><li><a class="tocitem" href="newsreport.html">News Report</a></li><li><a class="tocitem" href="generalmathematics2.html">General Mathematics 2</a></li><li><a class="tocitem" href="reactionwheelunicycle.html">Reaction Wheel Unicycle</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="hopffibration.html">Hopf Fibration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="hopffibration.html">Hopf Fibration</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/iamazadi/Porta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/iamazadi/Porta.jl/blob/master/docs/src/hopffibration.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Hopf-Fibration"><a class="docs-heading-anchor" href="#The-Hopf-Fibration">The Hopf Fibration</a><a id="The-Hopf-Fibration-1"></a><a class="docs-heading-anchor-permalink" href="#The-Hopf-Fibration" title="Permalink"></a></h1><p>The Hopf fibration is a fiber bundle with a two-dimensional sphere as the base space and circles as the fiber space. It is the geometrical shape that relates Einstein&#39;s spacetime to quantum fields. In this model, we visualize the Hopf fibration by first computing its points via a bundle atlas and then rendering the points in 3D space via stereographic projection. The projection step is necessary because the Hopf fibration is embedded in a four-space. Yet, it has only three degrees of freedom as a three-dimensional shape. The idea that makes this model more special and interesting than a typical visualization is the idea of <a href="http://drorbn.net/AcademicPensieve/Projects/PlanetHopf/">Planet Hopf</a>, due to Dror Bar-Natan (2010). The basic idea is that since the Hopf map takes the three-dimensional sphere into the two-dimensional sphere, we can pull the skin of the globe back to the three-sphere and visualize it.</p><p>Into the bargain, the Earth rotates about its axis every 24 hours. That spinning transformation of the Earth, together with the non-trivial product space of the Hopf bundle, can be encoded naturally into a monolithic visualization. It also makes sense to visualize differential operators in the Minkowski space-time as vectors in a cross-section of the Hopf bundle and then study the properties of spin-transformations. The choice of a gauge transformation (or trivialization) along with Lorentz transformations of Minkowski spacetime should not have any effect on physical laws. It is therefore a great model to understand these transformations and walk the road to reality. The following explains how the source code for generating animations of the Hopf fibration works (alternative views of Planet Hopf). We follow the beginning of chapter 4 of <a href="https://doi.org/10.1007/978-3-319-68439-0">Mark J.D. Hamilton (2018)</a> for a formal definition of the Hopf fibration as a fiber bundle. The book <em>Mathematical Gauge Theory</em> explains the Standard Model to students of both mathematics and physics, covers both the specific gauge theory of the Standard Model and generalizations, and is highly accessible and self-contained. Then, the definitions are going to be used to explain the source code in terms of computational methods and types.</p><p><img src="assets/fiberbundle/1.png" alt="image1"/> <img src="assets/fiberbundle/pi.png" alt="board2"/> <img src="assets/fiberbundle/2.png" alt="image2"/></p><p>First, let <span>$E$</span> and <span>$M$</span> be smooth manifolds. Then, <span>$\pi: E \to M$</span> is a surjective and differentiable map between smooth manifolds. Meaning, every element in <span>$M$</span> has some corresponding element in <span>$E$</span> via the map <span>$\pi$</span>. Now, let <span>$x \in M$</span> be a point. A <em>fiber</em> of <span>$\pi$</span> over point <span>$x$</span> is called <span>$E_x$</span> and defined as a non-empty subset of <span>$E$</span> as follows: <span>$E_x = \pi^{-1}(x) = \pi^{-1}(\{x\}) \subset E$</span>. The singleton of <span>$x$</span> is taken to the manifold <span>$E$</span> by the inverse of the map <span>$\pi$</span>. However, to have a set of more than one point let <span>$U$</span> be a subset of <span>$M$</span>, <span>$U \subset M$</span>. Then, we have <span>$E_U = \pi^{-1}(U) \subset E$</span>. In this case, <span>$E_U$</span> is the part of <span>$E$</span> above the subset <span>$U$</span>.</p><p><img src="assets/fiberbundle/3.png" alt="image3"/> <img src="assets/fiberbundle/connection.png" alt="board3"/> <img src="assets/fiberbundle/4.png" alt="image4"/></p><p>Next, define a global section of the map <span>$\pi$</span> like this: <span>$s: M \to E$</span>. Considering the definition of <span>$\pi: E \to M$</span>, the definition of the global section implies that the composition of <span>$\pi$</span> and <span>$s$</span> is the identity map <span>$\pi \ o \ s = Id_M$</span> over <span>$M$</span>. A section such as <span>$s$</span> can be a local one if we take a subset of <span>$M$</span> in the domain, <span>$U \subset M$</span>. Then, a local section is defined as <span>$s: U \to E$</span>. In a similar way the definition of the local section implies that its composition with <span>$\pi$</span> is the idenity map over the subset: <span>$\pi \ o \ s = Id_U$</span>. For all points <span>$x$</span> in subset <span>$U$</span>, the section <span>$s(x)$</span> is in the fiber <span>$E_x$</span> of <span>$\pi$</span> above <span>$x$</span>, if and only if <span>$s$</span> is a local section of <span>$\pi$</span>. In this pointwise case, the map <span>$\pi$</span> is restricted to subset <span>$U$</span>. In other words <span>$\pi: E \to U$</span>, where <span>$U \subset M$</span>.</p><p><img src="assets/fiberbundle/5.png" alt="image5"/> <img src="assets/fiberbundle/changeofbasis.png" alt="board4"/> <img src="assets/fiberbundle/6.png" alt="image6"/></p><p>In general, for two points <span>$x \not = y \in M$</span> that are not equal, the fibers <span>$E_x$</span> and <span>$E_y$</span> of <span>$\pi$</span> over <span>$x$</span> and <span>$y$</span> may not be embedded submanifolds of <span>$E$</span>, or even be diffeomorphic. That means, there may not be a differentiable and invertible map that takes fiber <span>$E_x$</span> into fiber <span>$E_y$</span>, and the tangent spaces of <span>$E_x$</span> and <span>$E_y$</span> over points <span>$x$</span> and <span>$y$</span> may not be naturally linear subspaces of the tangent space of <span>$E$</span>. But, it is different in the special instance where manifold <span>$E = M \times F$</span> is the product of <span>$M$</span> and the general fiber <span>$F$</span> and <span>$\pi$</span> as a map is the projection onto the first factor <span>$\pi: M \times F \to M$</span>. If that is the case, then fibers <span>$E_x, E_y \in F$</span> of <span>$\pi$</span> over the two distinct points <span>$x \not = y \in M$</span> are embedded submanifolds of <span>$E$</span> and diffeomorphic. To explain it more clearly, given that condition, there exists an invertible and smooth map taking one fiber to the other, and the tangent spaces of the fibers are directly summed with their respective dual subspaces at points in the fibers to span the whole tangent space of manifold <span>$E$</span> at points of <span>$\pi$</span> over <span>$x$</span> and <span>$y$</span>. Therefore, fiber bundles are the generalization of products <span>$E = M \times F$</span> as twisted products.</p><p><img src="assets/fiberbundle/7.png" alt="image7"/> <img src="assets/fiberbundle/section.png" alt="board5"/> <img src="assets/fiberbundle/8.png" alt="image8"/></p><p>Before we define the Hopf action, first describe a scalar multiplication rule between vectors and numbers. Let <span>$\R$</span> denote real numbers, <span>$\Complex$</span> complex numbers, and <span>$\mathbb{H}$</span> quaternionic numbers. On top of that, take a subset of these sets of numbers such that zero is not allowed to be in them, and denote the subsets as <span>$\R^*$</span>, <span>$\Complex^*$</span>, and <span>$\mathbb{H}^*$</span> respectively. Now, define the linear right action by scalar multiplication for <span>$\mathbb{K} = \mathbb{R}, \mathbb{C}, \mathbb{H}$</span> as the following: <span>$\mathbb{K^{n+1}}\setminus\{0\} \times \mathbb{K}^* \to \mathbb{K}^{n+1}\setminus\{0\}$</span>. For example, <span>$5 \in \mathbb{R}^*$</span> is a non-zero scalar number, whereas <span>$[1, 0, 0]^T \in \mathbb{R}^3\setminus\{0\}$</span> is a non-zero vector quantity. Per our definition, <span>$5$</span> acts on <span>$[1, 0, 0]^T$</span> on the right and yields <span>$[5, 0, 0] \in \mathbb{R}^3\setminus\{0\}$</span> as another vector. This rule works the same for fields <span>$\mathbb{K}$</span> even when the vectorial numbers are represented by matrices.</p><p><img src="assets/fiberbundle/9.png" alt="image9"/> <img src="assets/fiberbundle/reversiblemaps.png" alt="board6"/> <img src="assets/fiberbundle/10.png" alt="image10"/></p><p>The linear right action by multiplication is called a <em>free</em> action, because for <span>$x \in \mathbb{K}^{n+1}\setminus\{0\}$</span> and <span>$y \in \mathbb{k}^*$</span> the multiplication <span>$x \times y$</span> yields <span>$x$</span> if and only if <span>$y = Id$</span>, as the identity element. For example, if we let <span>$x = [0, 1, 0]^T, y = 1$</span>, then the result of the scalar multiplication is <span>$[0, 1, 0]^T \times 1 = [0, 1, 0]^T$</span>.</p><p><img src="assets/fiberbundle/11.png" alt="image11"/> <img src="assets/fiberbundle/s3.png" alt="board7"/> <img src="assets/fiberbundle/12.png" alt="image12"/></p><p>In addition, we define the unit n-sphere, for the Hopf action works on spheres. So, the unit sphere of dimension <span>$n$</span> is defined as: <span>$S^n:\{(w_1, w_2, ..., w_{n+1}) \in \mathbb{R}^{n+1} | \sum_{\substack{1 \leq i \leq n+1}}{w_i}^2 = 1\}$</span>. As an example, the unit circle <span>$S^1 \in \mathbb{C}$</span> is a one-dimensional sphere with <span>$n = 1$</span>, and <span>${w_1}^2 + {w_2}^2 = 1$</span>, where <span>$w_1$</span> and <span>$w_2$</span> are the horizontal and vertical axes in the complex plane, respectively.</p><p><img src="assets/fiberbundle/13.png" alt="image13"/> <img src="assets/fiberbundle/c2.png" alt="board8"/> <img src="assets/fiberbundle/14.png" alt="image14"/></p><p>Now, Hopf actions are defined as free actions:</p><ul><li><span>$S^n \times S^0 \to S^n \\$</span></li><li><span>$S^{2n+1} \times S^1 \to S^{2n+1} \\$</span></li><li><span>$S^{4n+3} \times S^3 \to S^{4n+3} \\$</span></li></ul><p>given by <span>$(x, \lambda) \mapsto x\lambda$</span>.</p><p><img src="assets/fiberbundle/15.png" alt="image15"/> <img src="assets/fiberbundle/nullcone.png" alt="board9"/> <img src="assets/fiberbundle/16.png" alt="image16"/></p><p>An example of a Hopf action is the multiplication of the three-sphere <span>$S^3 \cong SU(2) \subset \mathbb{C}^2$</span> on the right by the unit circle <span>$S^1 \cong U(1) \subset \mathbb{C}$</span>. Define the Hopf action as the map <span>$\Phi: S^3 \times S^1 \to S^3$</span> given by <span>$(v, w, \lambda) \mapsto (v, w) \sdot \lambda = (v\lambda, w\lambda)$</span>, for all points in the unit 3-sphere <span>$(v, w) \in S^3$</span> and the unit 1-sphere <span>$\lambda \in S^1$</span>. What&#39;s more, the Hopf action has two properties:</p><ol><li><span>$(v, w) \sdot (\lambda \sdot \mu) = ((v, w) \sdot \lambda) \sdot \mu$</span></li><li><span>$(v, w) \sdot 1 = (v, w)$</span></li></ol><p><span>$\forall (v, w) \in S^3, \ \lambda, \mu \in S^1$</span>.</p><p><img src="assets/fiberbundle/17.png" alt="image17"/> <img src="assets/fiberbundle/circle.png" alt="board10"/> <img src="assets/fiberbundle/18.png" alt="image18"/></p><p>The next idea is about the <em>orbit</em> of a point in the 3-sphere <span>$S^3$</span> under the Hopf action. The orbit map is defined as <span>$\phi: S^1 \to S^3$</span> given by <span>$\lambda \mapsto (v_0, w_0) \sdot \lambda$</span>, <span>$\forall (v_0, w_0) \in S^3$</span>. The orbit map <span>$\phi$</span> is injective and free, meaning that a point in <span>$S^3$</span> can not have many points in <span>$S^1$</span> and also there exists an identity element such that the action stabalizes a point in <span>$S^3$</span> such as <span>$(v_0, w_0)$</span>. Furthermore, the Hopf action <span>$\Phi: S^1 \to Diff(S^3)$</span> is a homomorphism. It preserves <span>$S^3$</span>. The Hopf action being a free action implies that the orbit of every point <span>$(v_0, w_0) \in S^3$</span> is an embedded circle <span>$S^1$</span>.</p><p><img src="assets/fiberbundle/19.png" alt="image19"/> <img src="assets/fiberbundle/derivative.png" alt="board11"/> <img src="assets/fiberbundle/20.png" alt="image20"/></p><p>Back to the topic of fiber bundles, we recall that the part of manifold <span>$E$</span> over subset <span>$U$</span> equals: <span>$E_U = \pi^{-1}(U) \subset E$</span>, where <span>$U \subset M$</span>. Here, there is an equivalence relation in the fiber <span>$E_x$</span> of <span>$\pi$</span> over <span>$x$</span>, since the orbit of a point in fiber <span>$E_x$</span> by <span>$\phi$</span> collapses onto a single point <span>$x \in U$</span> via the projection map <span>$\pi: S^3 \to S^3/\text{\textasciitilde}$</span>. After the collapse of every fiber in manifold <span>$E$</span>, the quotient space <span>$S^3/S^1$</span> is seen to be the projective complex line <span>$\mathbb{CP}^1 \cong S^2$</span>. The projective complex line is the ratio of two complex numbers. To see how the space of <span>$S^3$</span> is connected compared to <span>$S^1$</span>, note that every closed loop in <span>$S^3$</span> is shrinkable to a single point in a continuous way, tracing a local section. However, a closed loop in <span>$S^1$</span> is not shrinkable to a single point. This fact makes <span>$S^3$</span> a simply-connected space and <span>$S^1$</span> a not simply-connected space.</p><p><img src="assets/fiberbundle/21.png" alt="image21"/> <img src="assets/fiberbundle/hopfaction.png" alt="board12"/> <img src="assets/fiberbundle/22.png" alt="image22"/></p><p>We are now almost equipped with the tools to define a fiber bundle in a formal way. Let <span>$E, F, M$</span> be manifolds. The projection map <span>$\pi: E \to M$</span> is a surjective and differentiable map (Every element in <span>$M$</span> has some element in <span>$E$</span>). Then, <span>$(E, \pi, M, F)$</span> is called a fiber bundle, (or a locally trivial fibration, or a locally trivial bundle) if for every <span>$x \in M$</span> there exists an open neighborhood <span>$U \subset M$</span> around the point <span>$x$</span> such that the map <span>$\pi$</span> restricted to <span>$E_U$</span> can be trivialized as a cross product. Remember that <span>$E_U$</span> is the part of <span>$E$</span> of <span>$\pi$</span> over <span>$U$</span>. In other words, <span>$(E, \pi, M, F)$</span> is called a fiber bundle if there exists a diffeomorphism <span>$\phi_U: E_U \to U \times F$</span> such that <span>$pr_1 \ o \ \phi_U = \pi$</span>, meaning the projection onto the first factor of the trivialization map <span>$\phi_U$</span> is the same as the map <span>$\pi$</span>. Also, a fiber bundle is denoted by <span>$F \to E \xrightarrow{\pi} M$</span>. In this notation, <span>$E$</span> denotes the total space, <span>$M$</span> the base manifold, <span>$F$</span> the general fiber, <span>$\pi$</span> the projection, and <span>$(U, \phi_U)$</span> a local trivialization or bundle chart.</p><p><img src="assets/fiberbundle/23.png" alt="image23"/> <img src="assets/fiberbundle/linearsubspace.png" alt="board13"/> <img src="assets/fiberbundle/24.png" alt="image24"/></p><p>Using a local trivialization <span>$(U, \phi_U): E_x = \pi^{-1}(x)$</span> we find that the fiber <span>$E_x$</span> is an embedded submanifold of the total space <span>$E$</span> for every point <span>$x \in M$</span>. Meaning, the tangent space of fiber <span>$E_x$</span> is a linear subsapce of the tangent space of <span>$E$</span>. The direct sum of the tangent subspace of the general fiber and the tangent subspace of the base manifold equals the tangent space of the total space: <span>$T_{x}E = V_{x}E \bigoplus H_{x}E$</span>.</p><p><img src="assets/fiberbundle/25.png" alt="image25"/> <img src="assets/fiberbundle/fiber.png" alt="board14"/> <img src="assets/fiberbundle/26.png" alt="image26"/></p><p>The composition of the local trivialization with the projection onto the second factor gives us yet another useful map between fibers <span>$E_x$</span> over <span>$x$</span> and the general fiber <span>$F$</span>. It is a differentiable and invertible map (diffeomorphism) and equals <span>$\phi_U = pr_2 \ o \ \phi_U |_{E_x}: E_x \to F$</span>. Given that the local trivialization <span>$\phi_U: E_U \to U \times F$</span> is a diffeomorphism (invertible and smooth), the projection <span>$pr_1: U \times F \to U$</span> onto the first factor of <span>$\phi_U$</span> is a submersion. That is to say the differntial of <span>$pr_1$</span> is surjective. <span>$D pr_1: T(U \times F) \to TU$</span> takes vectors from the tangent space of <span>$U \times F$</span> into vectors in the tangent space of <span>$U$</span>, such that every element of <span>$TU$</span> has some element in <span>$T(U \times F)$</span>. As a result, the map <span>$\pi: E \to M$</span> is also a submersion, which means <span>$D \pi: TE \to TM$</span> is surjective. Every tangent vector in the codomain <span>$TM$</span> has some tangent vector in the domain <span>$TE$</span>.</p><p><img src="assets/fiberbundle/27.png" alt="image27"/> <img src="assets/fiberbundle/directsum.png" alt="board15"/> <img src="assets/fiberbundle/28.png" alt="image28"/></p><p>So far, we have established that the bundle projection map, taking points from the total space into points in the base space <span>$\pi: E \to M$</span>, is a submersion. For that reason, the tangent space of the base manifold <span>$M$</span> is a linear subset of the tangnet space of the total space manifold <span>$E$</span>. Now, we can use the <em>regular value theorem</em> for shining a light on the submersion of <span>$\pi$</span>. Let a point <span>$x \in M$</span> be a regular value of the smooth map <span>$\pi: E \to M$</span>, and let the fiber <span>$E_x = \pi^{-1}(x)$</span> be the preimage of the point <span>$x$</span>. Then, the map <span>$\pi^{-1}$</span> is an embedded submanifold of <span>$E$</span> of dimension <span>$dim \ E_x = dim \ E - dim \ M$</span>. Meaning, the tangent space of fiber <span>$E_x$</span> is a linear subspace of the tangent space of <span>$E$</span>. We can verify the result of the theorem for the Hopf bundle <span>$F \to E \xrightarrow{\pi} M$</span> where <span>$dim \ E = 3$</span> and <span>$dim \ M = 2$</span>. The regular value theorem implies that the Hopf fiber is one-dimensional, <span>$dim \ E_x = 3 - 2 = 1$</span>, as an embedded submanifold of the total space <span>$E$</span>. With that formal introduction we are going to sketch a visual 3D model next.</p><p><img src="assets/fiberbundle/29.png" alt="image29"/> <img src="assets/fiberbundle/path.png" alt="board16"/> <img src="assets/fiberbundle/30.png" alt="image30"/> <img src="assets/fiberbundle/31.png" alt="image31"/></p><h2 id="Import-the-Required-Packages"><a class="docs-heading-anchor" href="#Import-the-Required-Packages">Import the Required Packages</a><a id="Import-the-Required-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Import-the-Required-Packages" title="Permalink"></a></h2><p>Begin by importing a few software packages for doing algebraic operations, working with files and graphics processing units. Besides <strong>Porta</strong>, we need to use three packages: <a href="https://github.com/JuliaIO/FileIO.jl">FileIO</a>, <a href="https://github.com/MakieOrg/Makie.jl">GLMakie</a> and <a href="https://github.com/JuliaLang/julia/blob/master/stdlib/LinearAlgebra/src/LinearAlgebra.jl">LinearAlgebra</a>. First, <code>FileIO</code> is the main package for IO and loading all different kind of files, including images and Comma-Separated Value (CSV) files. Second, interactive data visualizations and plotting in Julia are done with <code>GLMakie</code>. Finally, <code>LinearAlgebra</code>, as a module of the Julia programming language, provides array arithmetic, matrix factorizations and other linear algebra related functionality. However, through years of working with geometrical structures and shapes we have encapsulated certain mathematical computations and transformations into custom types and interfaces, which make up most of the functionalities of project Porta. In addition, we wrapped complicated computer graphics workflows inside custom types in order to increase the interoperability of our types with those of external packages such as GLMakie.</p><pre><code class="language-julia hljs">    import FileIO
    import GLMakie
    import LinearAlgebra
    using Porta</code></pre><h2 id="Set-Hyperparameters"><a class="docs-heading-anchor" href="#Set-Hyperparameters">Set Hyperparameters</a><a id="Set-Hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#Set-Hyperparameters" title="Permalink"></a></h2><p>There are essential hyperparameters that determine the complexity of graphics rendering as well as the position and orientation of a camera, through which we render a scene. Since the output of the model is an animation video, we need to set the figure size to 1920 by 1080 to have a full high definition window, in which the scene is located. Most of the shapes and objects that we put inside of the scene are two-dimensional surfaces. Therefore, the segmentation of most shapes requires two integer values for determining how much compute power and resolution we are willing to spend on the animation. Furthermore, the shape of a circle is the most common in our scenes because of the magic of complex numbers. It is known that using 30 segments results in smooth low-polygon circles. So for a two-dimensional sphere a 30 by 30 segmented two-surface should look good. Set the segments equal to 30, and less curvy shapes will look even better in consequence. But, an animation extends through time frame by frame and so we need to set the total number of frames. In this way, specifying the number of frames determines the length of the video. For example, 1440 frames make a one-minute video at 24 frames per second.</p><pre><code class="language-julia hljs">    figuresize = (1920, 1080)
    segments = 30
    frames_number = 1440</code></pre><p>A model means a complicated geometrical shape contained inside a graphical scene. Every model has a name to use as the file name of the output video. Here, we choose the name <code>planethopf</code> as we construct an alternative view of the <a href="http://drorbn.net/AcademicPensieve/Projects/PlanetHopf/">Planet Hopf</a> by Dror Bar-Natan (2010). Heinz Hopf in 1931 discovered a way to join circles over the skin of the globe. The discovery defines a fiber bundle where the base space is the spherical Earth and the fibers are circles. But, the circles are all mutually parallel and linked. Moreover, the Earth goes through a full rotation about the axis that connect the poles every 24 hours. So it is not surprising that the picture of a non-trivial bundle and the spinning of the base space coordinates (longitudes) makes for a ridiculous geometric shape. But, the surprising fact is that all of it is visualizable as a 3D object. Then, we use a dictionary that maps indices to names in order to keep track of boundary data on the globe and the name of each boundary as a sovereign country.</p><pre><code class="language-julia hljs">    modelname = &quot;planethopf&quot;
    indices = Dict()</code></pre><p>The Hopf fibration, as a fiber bundle, has an inner product space. The inner product space is symmetric, linear and positive semidefinite. The last property means that the product of a point in the bundle with itself is always non-negative, and it is zero if and only if the point is the zero vector. The abstract inner product space allows us to talk about the length of vectors, the distance between two points and the idea of orthogonality between two vectors. A pair of vectors are orthogonal when they make a right angle with each other and as a consequence their product is equal to zero. For all <span>$u, v, v_1, v_2 \in V$</span> and <span>$\alpha, \beta \in \R$</span> the following are the properties of the abstract inner product space:</p><ul><li>Symmetric: <span>$&lt;u, v&gt; = &lt;v, u&gt;$</span></li><li>Linear: <span>$&lt;u, \alpha v_1 + \beta v_2&gt; = \alpha &lt;u, v_1&gt; + \beta &lt;u, v_2&gt;$</span></li><li>Positive semidefinite: <span>$&lt;u, u&gt; \geq 0$</span> for all <span>$u \in V with &lt;u, u&gt; = 0$</span> if and only if <span>$u = 0$</span></li></ul><p>Now, in order to skin the horizontal cross-sections of the bundle for visualization we need to start with a base point, which is denoted by <code>x</code>. At the tangent space of the base point <code>q</code>, the inner product space (characterized by a connection one-form) splits the tangent space of the bundle <span>$E$</span> at <code>x</code> into two linear subspaces: horizontal and vertical.</p><p><span>$T_q E = V_q E \bigoplus H_q E$</span></p><p>In terms of the connection, the two subspcaes are orthogonal. A <code>chart</code> is a four-tuple of real numbers to be used as a pair of closed intervals in the horizontal subspace. Then, using the exponential map one can travel in both horizontal and vertical directions and cover the whole bundle within the lengths of the chart intervals. Within the boundary of the chart and with an additional vertical coordinate (a gauge) we can define a tubular neighborhood of the base point <code>q</code>. The first two elements of the four-tuple <code>chart</code> give the interval along the first basis vector and the last two elements give the interval along the second basis vector. As for the third basis vector of the tangent space (the vertical subspace) we use a beginning and an ending <em>gauge</em>.</p><p>For the purpose of the construction of the Hopf fibration we define the bundle <em>atlas</em> of a general fiber bundle <span>$F \to E \xrightarrow{\pi} M$</span> as an open covering <span>$\{U_i\}_{i \in I}$</span> of the base manifold <span>$M$</span> together with bundle charts <span>$\phi_i: E_{U_i} \to U_i \times F$</span>. Putting the open covering with bundle charts a bundle atlas is denoted by <span>$\{U_i, \phi_i\}_{i \in I}$</span>. The index <span>$i$</span> suggests that a bundle atlas should have more than one bundle chart whenever it is a non-trivial bundle (a twisted product rather than a Cartesian product). In order to cover the Hopf bundle we use the exponential matrix function supplied with linear combinations of elements from the Lie algebra <span>$so(4)$</span>, which produces elements in the Lie group <span>$SO(4)$</span> that push a base point around the 3-sphere. As a side note, a <strong>Lie algebra</strong> is a vector space <span>$V$</span> that is equipped with the Lie bracket map <span>$[\sdot, \sdot]: V \times V \to V$</span>, with <span>$[\sdot, \sdot]$</span> having three properties: bilinear, antisymmetric and satisfies the <em>Jacobi identity</em>. We choose a base point in the 3-sphere <span>$q \in S^3$</span> and then use Lie algebra elements before exponentiation in order to rotate the 3-sphere to cover every other point in the total space <span>$S^3$</span> over the <code>chart</code>.</p><pre><code class="language-julia hljs">    q = Quaternion(ℝ⁴(0.0, 0.0, 1.0, 0.0))
    chart = (-π / 4, π / 4, -π / 4, π / 4)</code></pre><p>Next, we define five scalars in the Lie algebra of <span>$so(2)$</span>, identified with <span>$i\mathbb{R}$</span>, in order to provide different gauge transformations for pullbacks by the Hopf fibration (whirls and base maps). The exponential function takes the gauge values to the unit circle <span>$S^1 = U(1) \cong SO(2)$</span> given by <code>exp(im * gauge)</code>. For creating a clearer view we are going to slice up the Hopf fibers (orbits) and set different values for their respective alpha channels. The names <code>gauge1</code>, <code>gauge2</code>, <code>gauge3</code>, <code>gauge4</code> and <code>gauge5</code> are used to provide the Hopf actions when we construct and update the shapes. 0.0 means the trivial action whereas 2π means the full orbit around a Hopf fiber. Looking at the values of these names we can see that a Hopf fiber will be cut into four quarters. We can make some quarters opaque and others see-through for better visibility.</p><pre><code class="language-julia hljs">    gauge1 = 0.0
    gauge2 = π / 2
    gauge3 = float(π)
    gauge4 = 3π / 2
    gauge5 = 2π</code></pre><p>The fundamental physics is based on the gauge symmetry of the product <span>$SU(3) \times SU(2) \times U(1)$</span> and the symmetry of spacetime as a Riemannian manifold <span>$M$</span> that is equipped with a metric. Therefore, physical laws in nature must be the same under two sets of choices: the choice of gauge transformations and the choice of an inertial reference frame in spacetime. In this model, we understand the choice of the guage symmetry by studying the Hopf action and the choice of an inertial frame in Minkowski space-time by a change-of-basis transformation on the Hopf bundle. The change-of-basis transformation is denoted by matrix <code>M</code> and is applied to the total space of the Hopf bundle via a matrix-vector product. Here, we initialize the matrix <code>M</code> with the idenity.</p><pre><code class="language-julia hljs">    M = I(4)</code></pre><p>In order to get the essence of these different choices and integrate them into a visual model we first note that Lorentz transformations of null vectors in the tangent space of spacetime is the same as transforming any other timelike (non-null) vectors. Second, The Hopf bundle of the 3-sphere has a representation in the Lie group <span>$S^3 = SU(2)$</span> and the Hopf action is represented by actions of <span>$S^1 = U(1)$</span> as a linear scalar multiplication on the right. But, null vectors have length zero in terms of the Lorentzian metric, whereas the Hopf bundle is made of vectors of unit length in terms of the Euclidean metric. Fortunately, these vectors coincide as unit quaternions and so their transformations can be unified into a single visual model. If we coordinatize a null vector in spacetime as <code>u = 𝕍(T, X, Y, Z)</code> then the corresponding quaternion <code>q = Quaternion(T, X, Y, Z)</code> takes the same coordinates. We assert that <code>u</code> is null and <code>q</code> is of unit norm, with an approximate equality check. The precision of the assertion is given by the name <code>tolerance</code>, which equals <code>1e-3</code>.</p><pre><code class="language-julia hljs">    T, X, Y, Z = vec(normalize(ℝ⁴(1.0, 0.0, 1.0, 0.0)))
    u = 𝕍(T, X, Y, Z)
    q = Quaternion(T, X, Y, Z)
    tolerance = 1e-3
    @assert(isnull(u, atol = tolerance), &quot;u in not a null vector, $u.&quot;)
    @assert(isapprox(norm(q), 1, atol = tolerance), &quot;q in not a unit quaternion, $(norm(q)).&quot;)</code></pre><p>The camera is a viewport trough which we see the scene. It is a three-dimensional camera and much like a drone it has six features to help position and orient itself in the scene. Accordingly, a three-vector in the Euclidean 3-space <span>$E^3$</span> determins its position in the scene, another 3-vector specifies the point at which it looks, and a third vector controls the <em>up</em> direction of the camera. The third 3-vector is needed because the camera can rotate through 360 degrees about the axis that connects its own position to the position of the subject. Using these three 3-vectors we control how far away we are from the subject, and how upright the subject is. </p><pre><code class="language-julia hljs">    eyeposition = normalize(ℝ³(1.0, 1.0, 1.0)) * π * 0.8
    lookat = ℝ³(0.0, 0.0, 0.0)
    up = normalize(ℝ³(1.0, 0.0, 0.0))</code></pre><p>Each of the <code>eyeposition</code>, <code>lookat</code> and <code>up</code> vectors are in the three-real-dimensional vector space ℝ³. The structure of the abstract vector space of ℝ³ includes: associativity of addition, commutativity of addition, the zero vector, the inverse element, distributivity Ι, distributivity ΙΙ, associativity of scalar multiplication, and the unit scalar 1. Also, the product space associated with ℝ³ is symmetric, linear and positive semidefinite (see <em>real3_tests.jl</em>). The same goes for the structure of 4-vectors in ℝ⁴ as we are going to encounter in this model. An abstract vector space <span>$(V, \mathbb{K}, +, .)$</span> consists of four things:</p><ul><li>A set of vector-like objects <span>$V = \{u, v, ...\}$</span></li><li>A field <span>$\mathbb{K}$</span> of scalar numbers, complex numbers, quaternions, or octonions (any one of the division algebras)</li><li>An addition operation <span>$+$</span> for elements of <span>$V$</span> that dictates how to add vectors: <span>$u + v$</span></li><li>A scalar multiplication operator <span>$.$</span> for scaling a vector by an element of the field</li></ul><p>An abstract vector space satisfies eight axioms. For all vectors <span>$u, v, w \in V$</span> and for all scalars <span>$\alpha, \beta \in \mathbb{K}$</span> the following properties are true:</p><ol><li>Associativity of addition: <span>$u + (v + w) = (u + v) + w$</span></li><li>Commutativity of addition: <span>$u + v = v + u$</span></li><li>There exists a zero vector <span>$0 \in V$</span> such that <span>$u + 0 = 0 + u = u$</span></li><li>For every <span>$u$</span> there exists an inverse element <span>$-u$</span> such that <span>$u + (-u) = u - u = 0$</span></li><li>Distributivity I: <span>$\alpha (u + v) = \alpha u + \alpha v$</span></li><li>Distributivity II: <span>$(\alpha + \beta) u = \alpha u + \beta u$</span></li><li>Associativity of scalar multiplication: <span>$\alpha (\beta u) = (\alpha \beta) u$</span></li><li>There exists a unit scalar <span>$1$</span> such that <span>$1u = u$</span></li></ol><p>Interestingly, if the field <span>$\mathbb{K}$</span> is an Octonian number then the axiom of the commutativity of addition becomes false. The plan is to first load a geographic data set, then construct a few shapes, and animate a four-stage transformation of the shapes. Model versioning can be applied here using different stages. The transformations are subgroups of the Lorentz transformation in the Minkowski vector space 𝕍, which is a tetrad and origin point away from the Minkowski space-time 𝕄. Both 𝕍 and 𝕄 inherit the properties of the abstract vector space. See <em>minkowskivectorspace_tests.jl</em> and <em>minkowskispacetime_tests.jl</em> for use cases.</p><pre><code class="language-julia hljs">    totalstages = 4</code></pre><h2 id="Load-the-Natural-Earth-Data"><a class="docs-heading-anchor" href="#Load-the-Natural-Earth-Data">Load the Natural Earth Data</a><a id="Load-the-Natural-Earth-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Natural-Earth-Data" title="Permalink"></a></h2><p>Next, we need to load two image files: an image to be used as a color reference, and another one to be used as surface texture for sections of the Hopf bundle. This is the first example of using <code>FileIO</code> to load image files from hard drive memory. Both images are made with a software called <a href="https://www.qgis.org/en/site/">QGIS</a>, which is a geographic information system software that is free and open-source. But, the data comes from <a href="https://www.naturalearthdata.com/">Natural Earth Data</a>. Natural Earth is a public domain map dataset available at 1:10m, 1:50m, and 1:110 million scales. Featuring tightly integrated vector and raster data, with Natural Earth you can make a variety of visually pleasing, well-crafted maps with cartography or GIS software. We downloaded the <a href="https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/cultural/ne_10m_admin_0_countries.zip">Admin 0 - Countries</a> data file from the 1:10m Cultural Vectors link of the Downloads page. It is a large-scale map that contains geometry nodes and attributes.</p><pre><code class="language-julia hljs">    reference = FileIO.load(&quot;data/basemap_color.png&quot;)
    mask = FileIO.load(&quot;data/basemap_mask.png&quot;)</code></pre><p>As for the image files, we paint the boundaries using the gemometry nodes, and add a grid to be able to visualize distortions of the Euclidean metric of the underlying surface. Therefore, the reference is the clean image from which we pick colors, whereas the mask has a grid and transparency for visualization purposes.</p><pre><code class="language-julia hljs">    attributespath = &quot;data/naturalearth/geometry-attributes.csv&quot;
    nodespath = &quot;data/naturalearth/geometry-nodes.csv&quot;
    countries = loadcountries(attributespath, nodespath)</code></pre><p>The geometry nodes of the data set consist of latitudes and longitudes of boundaries. But, geometry attributes feature various geographical, cultural, economical and geopolitical values. Of these features we only need the names and geographic coordinates. To not limit the use cases of this model, the generic function <code>loadcountries</code> loads all of the data features by supplying it with the file paths of attributes and nodes. Data versioning can be applied here using different file versions. The attributes and nodes files are comma-separated values.</p><p>At a high level of description, the process of loading boundary data is as follows: First, we use FileIO to open the attributes file. Second, we put the data in a <a href="https://github.com/JuliaData/DataFrames.jl"><code>DataFrames</code></a> object to have in-memory tabular data. Third, sort the data according to shape identification. Fourth, open the nodes file in a DataFrame. Fifth, group the attributes by the name of each sovereign country. Sixth, determine the number of attribute groups by calling the generic function <code>length</code>. Seventh, define a constant <code>ϵ = 5e-3</code> to limit the distance between nodes so that the computational complexity becomes more reasonable. Eighth, define a dictionary that has the keys: <code>shapeid</code>, <code>name</code>, <code>gdpmd</code>, <code>gdpyear</code>, <code>economy</code>, <code>partid</code>, and <code>nodes</code>. Finally, for each group of the attributes we extract the data corresponding to the dictionary keys and push them into array values.</p><p>Part of the difficulty with the data loading process is that each sovereign country may have more than one connected component (closed boundary). That is why we store part identifications as one of the dictionary keys. In this process, the part with the greatest number of nodes is chosen as the main part and is pushed into the corresponding array value. All of the array values are ordered and have the same length so that indexing over the values of more than one key becomes easier. Once the part ID of each country name is determined, we make a subset of the data frame related to the part ID and then extract the geographic coordinates in terms of latitudes and longitudes. In fact, we make a histogram of each unique part ID and count the number of coordinates. The part ID with the greatest number of coordinates is selected for creating the subset of the data frame. Next, the coordinates are transformed into the Cartesian coordinate system from the Geographic one.</p><p>Finally, we <code>decimate</code> a curve containing a sequence of coordinates by removing points from the curve that are farther from each other than the given threshold <code>ϵ</code>. It is a step to make sure that the boundary data has superb quality while managing the size of data for computation complexity. The generic function <code>decimate</code> implements the <a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Ramer–Douglas–Peucker</a> algorithm. It is an iterative end-point fit algorithm suggested by Dror Bar-Natan (2010) for this model. Since a boundary is modelled as a curve of line segments, we set a segmentation limit. But, the decimation process finds a curve that is similar in shape, yet has fewer number of points with the given threshold <code>ϵ</code>. In short, <code>decimate</code> recursively simplifies the segmented curve of a closed boundary if the maximum distance between a pair of consecutive points is greater than <code>ϵ</code>. The <em>distance</em> between two abstract vectors is given by <span>$d(u, v) \equiv ||u - v|| = \sqrt{&lt;(u - v), (u - v)&gt;}$</span>.</p><pre><code class="language-julia hljs">    boundary_names = [&quot;United States of America&quot;, &quot;Antarctica&quot;, &quot;Australia&quot;, &quot;Iran&quot;, &quot;Canada&quot;, &quot;Turkey&quot;, &quot;New Zealand&quot;, &quot;Mexico&quot;, &quot;Pakistan&quot;, &quot;Russia&quot;]
    boundary_nodes = Vector{Vector{ℝ³}}()
    for i in eachindex(countries[&quot;name&quot;])
        for name in boundary_names
            if countries[&quot;name&quot;][i] == name
                push!(boundary_nodes, countries[&quot;nodes&quot;][i])
                println(name)
                indices[name] = length(boundary_nodes)
            end
        end
    end</code></pre><p>As the boundary data is massive in number (248 countries) we need to select a subset for visualization. 10 countries selected from a linear space of alphabetically sroted names should be representative of the whole Earth. Then again, using only three distinct points in the 2-sphere one can infer the transformations from the sphere into itself. Also, Antarctica should be added due to its special coordinates at the south pole, to give the user a better sense of how bundle sections are expanded and distorted. As soon as we have the names of the selection, we can proceed with populating the dictionary of <code>indices</code> that relates the name of each country with the corresponding index in boundary data. Using the dictionary we can read the attributes of countries by giving just the name as argument.</p><pre><code class="language-julia hljs">    points = Vector{Quaternion}[]
    for i in eachindex(boundary_nodes)
        _points = Quaternion[]
        for node in boundary_nodes[i]
            r, θ, ϕ = convert_to_geographic(node)
            push!(_points, q * Quaternion(exp(ϕ / 4 * K(1) + θ / 2 * K(2))))
        end
        push!(points, _points)
    end</code></pre><p>We instantiate a vector of a vector of type <code>Quaternion</code> to store boundary data. The outermost vector contains elements of different countries. But, the innermost vector contains the pullback of the geographic nodes by the Hopf map in the 3-sphere. After conversion to the Geographic coordinate system from the Cartesian coordinates, the points are pulled back by <span>$\pi$</span> using the statement <code>q * Quaternion(exp(ϕ / 4 * K(1) + θ / 2 * K(2)))</code>. It is a right multiplication of the base point <code>q</code> by the exponential function, supplied with the geographic coordinates <code>θ</code> and <code>ϕ</code>. Now that we have the points we can make a 3D scene.</p><h2 id="Make-a-Computer-Graphical-Scene"><a class="docs-heading-anchor" href="#Make-a-Computer-Graphical-Scene">Make a Computer Graphical Scene</a><a id="Make-a-Computer-Graphical-Scene-1"></a><a class="docs-heading-anchor-permalink" href="#Make-a-Computer-Graphical-Scene" title="Permalink"></a></h2><p>Scenes are fundamental building blocks of <code>GLMakie</code> figures. In this model, the layout of the <code>Figure</code> (graphical window) is a single <code>Scene</code>, because we have been able to directly plot all of the information about the bundle geometry and topology inside the same scene. The figure is supplied with the hyperparameter <code>figuresize</code> that we defined earlier. Then, we set a black theme to have black background around the window at the margins. Next, we instantiate a gray point light and a lighter gray ambient light. The lights together with the figure are then passed to <code>LScene</code> to construct our scene. We pass the symbol <code>:white</code> as the argument to the <code>background</code> keyword as it makes for the most visible scene.</p><pre><code class="language-julia hljs">    makefigure() = GLMakie.Figure(size = figuresize)
    fig = GLMakie.with_theme(makefigure, GLMakie.theme_black())
    pl = GLMakie.PointLight(GLMakie.Point3f(0), GLMakie.RGBf(0.0862, 0.0862, 0.0862))
    al = GLMakie.AmbientLight(GLMakie.RGBf(0.9, 0.9, 0.9))
    lscene = GLMakie.LScene(fig[1, 1], show_axis=false, scenekw = (lights = [pl, al], clear=true, backgroundcolor = :white))</code></pre><h2 id="Construct-Base-Maps"><a class="docs-heading-anchor" href="#Construct-Base-Maps">Construct Base Maps</a><a id="Construct-Base-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-Base-Maps" title="Permalink"></a></h2><p>The base map is the pullback of the skin of the globe <span>$U \subset S^2$</span> by the Hopf map <span>$\pi: S^3 \to S^2$</span>, representing a local horizontal cross-section of the bundle. The pushforward of horizontal vectors by the Hopf map leaves them unchanged. However, vectors in the vertical subsapce of the tangent space of the Hopf bundle are in the kernel of the Hopf map (they are sent to zero).</p><p>We use a 64-bit floating point number to parameterize an element of the Lie algebra <span>$so(2)$</span>, before exponentiating it into an element of the Lie group <span>$SO(2)$</span> to be used for the orbit map <span>$\phi: S^1 \to S^3$</span>, because a local horizontal cross-section uses the same scalar number for the entirety of subset <span>$U \subset S^2$</span>. The subset <span>$U$</span> is bounded with a two-dimensional chart. A chart can be thought of as a rectangle whose sides are at most π in length. But, the length of a great circle of the three-dimensional sphere is 2π and the maximum length of chart sides is limited, unless we want to cover <span>$S^3$</span> twice. To keep things simple, we use one bundle chart and cover a subset <span>$U$</span> of side length π. The Hopf bundle does not admit a global section. After exponentiating the base point <code>q</code> in horizontal directions for a magnitude beyond π, the orientation of the surface reverses and a sharp twist of the surface happens.</p><p>The Hopf bundle is embedded in ℝ⁴, the real-four-dimensional space. The coordinates are defined as unit quaternions where the basis vectors are represented by the symmetry group of the rotations of an orthogonal tetrad, namely <span>$SO(4)$</span>. vectors <span>$u$</span> and <span>$v$</span> are orthogonal if and only if their inner product equals zero <span>$&lt;u, v&gt; = 0$</span>. When we talk about Hopf actions and bundle charts, we talk about values that are used to linearly combine elements of the Lie algebra of <span>$so(4)$</span>, vectors in the tangent space of the bundle at point <code>x</code>. Then, we use the matrix exponential map for computing Lie group values in <span>$SO(4)$</span>. Given a fixed <code>gauge</code>, a point in the Lie group stemming from base point <code>x</code> is reconstructed from a Lie algebra element by executing the statement <code>x * Quaternion(exp(θ * K(1) + -ϕ * K(2)) * exp(gauge * K(3)))</code>, where scalars <code>θ</code> and <code>ϕ</code> denote the latitude and longitude components in the bundle chart, respectively. <code>K(1)</code> and <code>K(2)</code> denote 4x4 matrices with real elements as basis vectors of the Lie algebra <span>$so(4)$</span>. The tangent space of the bundle at point <code>x</code> spans horizontally with the exponential map of a linear combination of basis vectors <code>K(1)</code> and <code>K(2)</code>, whereas it spans vertically in the <code>K(3)</code> direction. This way we get a strictly horizontal section of the bundle in terms of elements of the Lie group <span>$SO(4)$</span>, given a <code>gauge</code>. The elements of <span>$SO(4)$</span> go on to push the base point <code>x</code> around and end up as observables to be rendered graphically.</p><pre><code class="language-julia hljs">    lspaceθ = range(chart[1], stop = chart[2], length = segments)
    lspaceϕ = range(chart[3], stop = chart[4], length = segments)
    [project(normalize(M * (x * Quaternion(exp(θ * K(1) + -ϕ * K(2)) * exp(gauge * K(3)))))) for ϕ in lspaceϕ, θ in lspaceθ]</code></pre><p>Using the eigendecomposition method <code>LinearAlgebra.eigen</code>, we can compute the matrix <code>M</code> to change the basis of the bundle while keeping the coordinates invariant. So the change-of-basis is the final step of the construction of the observables after using the geographic coordinates and the gauge. <a href="https://github.com/JuliaGizmos/Observables.jl/tree/master"><code>Observables.jl</code></a> allows us to define the points that are to be rendered in the scene, in a way that they can listen to changes dynamically. Later, when we apply transformations to the bundle, including the change-of-basis, the idea is to only change the top-level observables and avoid reconstructing the scene entirely. The change of basis is a bilinear transformation of the tetrad (of Minkowski space-time 𝕄) in ℝ⁴ as a matrix-vector product (<code>M * x</code> for example). Here we denote the transformation as matrix <code>M</code>, which takes a <code>Quaternion</code> number as input and spits out a new number of the same type. The input and output bases must be orthonormal as the numbers must remain unit quaternions after the transformation. Constructing a base map requires a few arguments: the scene object, the base point <code>q</code>, the <code>gauge</code>, the change-of-basis transformation <code>M</code>, the <code>chart</code>, the number of <code>segments</code> of the lattice of observables, the tuxture of the surface and the optional transparency setting. Construct four base maps in order to visualize a more complete picture of the Hopf fibration using four different sections. But, the sections are going to be distinguished from one another and updated with gauge transformations later when we animate them.</p><pre><code class="language-julia hljs">    basemap1 = Basemap(lscene, q, gauge1, M, chart, segments, mask, transparency = true)
    basemap2 = Basemap(lscene, q, gauge2, M, chart, segments, mask, transparency = true)
    basemap3 = Basemap(lscene, q, gauge3, M, chart, segments, mask, transparency = true)
    basemap4 = Basemap(lscene, q, gauge4, M, chart, segments, mask, transparency = true)</code></pre><h2 id="Construct-Whirls"><a class="docs-heading-anchor" href="#Construct-Whirls">Construct Whirls</a><a id="Construct-Whirls-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-Whirls" title="Permalink"></a></h2><p>A <code>Whirl</code> is the shape of a closed boundary in the map of the Earth that is pulled back by the Hopf map <span>$\pi: S^3 \to S^2$</span>. As a reminder, boundaries on the map of the Earth are specified by two real values: latitude <code>θ</code> and longitude <code>ϕ</code>. The boundary of each country in <code>boundary_names</code> is lifted up from the base manifold using the following statement: <code>q * Quaternion(exp(ϕ / 4 * K(1) + θ / 2 * K(2)))</code>. The pullback operation is realized by pushing the base point <code>q</code> in a horizontal direction given by coordinates on the surface of the Earth. Then, a gauge transformation is applied by executing the statement <code>x * Quaternion(exp(K(3) * gauge))</code>, with the given scalar <code>gauge</code> in the direction <code>K(3)</code> of the tangent space at point <code>x</code> of the bundle. By varying <code>gauge</code> in a linear space of floating point values, a <code>Whirl</code> (a pullback by the Hopf map) takes a three-dimensional volume. In the special case where <code>gauge</code> is a range of values, starting at zero and stopping at 2π, the Whirl makes a Hopf band. The degree of the twist in the band is directly proportional to the value of <code>gauge</code>. Multiplying <code>x</code> on the right by the exponentiation of <code>K(3) * gauge</code> pushes <code>x</code> in the vertical subspace of the bundle and makes an orbit. Therefore, the orbit map <span>$\phi: S^1 \to S^3$</span> is given by <code>x[i] * Quaternion(exp(K(3) * gauge)</code>.</p><pre><code class="language-julia hljs">    lspacegauge = range(gauge1, stop = gauge2, length = segments)
    [project(normalize(M * (x[i] * Quaternion(exp(K(3) * gauge))))) for i in 1:length(x), gauge in lspacegauge]</code></pre><p>There are four sets of whirls: some whirls are more solid and some whirls are more transparent. This separation is done to highlight the antipodal points of the three-dimensional sphere <span>$S^3$</span>, given by <span>$x_1^2 + x_2^2 + x_3^2 + x_4^2 = 1$</span>, where <span>$[x_1, x_2, x_3, x_4]^T \in \R^4$</span>. It also helps to visualize the direction of the null plane under transformations of the bundle. Since every pair of points that are infinitestimally close to each other in a horizontal cross-section, defines a differential operator. And Hopf actions, transformations from the bundle into itself change the direction of the operator as it twists. The operator is also called a spin-vector in Minkowski vector space 𝕍. Therefore it can be visualized directly how the operator changes sign by comparing a pullback into <span>$S^3$</span> at antipodal points of an orbit.</p><pre><code class="language-julia hljs">    whirls1 = []
    whirls2 = []
    whirls3 = []
    whirls4 = []
    for i in eachindex(boundary_nodes)
        color1 = getcolor(boundary_nodes[i], reference, 0.1)
        color2 = getcolor(boundary_nodes[i], reference, 0.2)
        color3 = getcolor(boundary_nodes[i], reference, 0.3)
        color4 = getcolor(boundary_nodes[i], reference, 0.4)
        whirl1 = Whirl(lscene, points[i], gauge1, gauge2, M, segments, color1, transparency = true)
        whirl2 = Whirl(lscene, points[i], gauge2, gauge3, M, segments, color2, transparency = true)
        whirl3 = Whirl(lscene, points[i], gauge3, gauge4, M, segments, color3, transparency = true)
        whirl4 = Whirl(lscene, points[i], gauge4, gauge5, M, segments, color4, transparency = true)
        push!(whirls1, whirl1)
        push!(whirls2, whirl2)
        push!(whirls3, whirl3)
        push!(whirls4, whirl4)
    end</code></pre><p>The color of a <code>Whirl</code> should match the color of the inside of its own boundary at every horizontal section, also known as a base map. The generic function <code>getcolor</code> finds the correct color to set for the <code>Whirl</code>. It takes as input a closed boundary (a vector of Cartesian points), a color reference image and an alpha channel value to produce an <code>RGBA</code> 4-color. <code>getcolor</code> finds a color according to the following steps: First, it determines the number of points in the given boundary. Second, gets the size of the reference color image as height and width in pixels. Third, converts all of the boundary points to Geographic coordinates. Fourth, finds the minimum and maximum values of the latitudes and longitudes of the boundary. Fifth, creates a two-dimensional linear space (a flat grid or lattice) that ranges within the upper and lower bounds of the latitudes and longitudes. Sixth, finds the Cartesian two-dimensional coordinates of the points in the image space by normalizing the geographic coordinates and multiplying them by the image size. Seventh, picks the color of each grid point with the Cartesian two-dimensional coordinates in the image space as the index. Eighth, Makes a histogram of the colors by counting the number of each color. Finally, sorts the histogram and picks the color with the greatest number of occurance. (See <em>earth.jl</em> from the <em>src</em> directory for implementation.)</p><p>However, step seven makes sure that the coordinates in the linear 2-space are inside the closed boundary, otherwise it skips the index and continues with the next index in the grid. In this way we don&#39;t pick colors from the boundaries of neighboring countries over the globe. The generic function <code>isinside</code> is used by <code>getcolor</code> to determine whether the given point is inside the given boundary or not. But first, the boundary needs to become a polygon in the Euclidean 2-space of coordinates in terms of latitude and longitude. This is the same as geographic coordinates with the radius of Earth set equal to 1 identically, hence the spherical Earth model of the ancient Greeks. After we make a polygon out of the boundary, the generic function <code>rayintersectseg</code> determines whther a ray cast from a point of the linear grid intersects an edge with the given point <code>p</code> and <code>edge</code>. Here, <code>p</code> is a two-dimensional point and <code>edge</code> is a tuple of such points, representing a line segment. Eventhough this algorithm should work in theory, some boundaries are too small to yield a definite color via <code>getcolor</code> and the color inference algorithm returns a false negative in those cases. So the default color may be white for a limited number of cases out of 248 countries. Once we have the color of the whirls, we can proceed to construct the whirls by supplying the generic function <code>Whirl</code> with the following arguments: the scene object, the boundary points lifetd via an arbitrary section, the first fiber action value (gauge), the second action value, the change-of-basis function <code>M</code>, the number of surface segments, the color and the optional transparency setting.</p><h2 id="Compute-a-Four-Screw"><a class="docs-heading-anchor" href="#Compute-a-Four-Screw">Compute a Four-Screw</a><a id="Compute-a-Four-Screw-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-a-Four-Screw" title="Permalink"></a></h2><p>We are going to execute a motion around a closed loop in the Lie group <span>$SL(2, \mathbb{C})$</span>, and then multiply every point in the Hopf bundle by an element of the loop. A four-screw is a subset of the Lie group <span>$SL(n, \mathbb{K}) = \{A \in Mat(n \times n, \mathbb{K}) | det(A) = 1\}$</span>, square matrices of <code>Complex</code> numbers whose volume form (determinant) equals 1. Here, the number <span>$n = 2$</span> and the field <span>$\mathbb{K} = \mathbb{C}$</span>. A four-screw is a kind of restricted Lorentz transformation where a z-boost and a proper rotation of the celestial sphere are applied. The transformation lives in a four-complex dimensional space and it has six degrees of freedom (the same number of dimensions as <span>$SO(4)$</span>). By parameterizing a four-screw one can control how much boost and rotation a transformation shuld have. Here, <code>w</code> as a positive scalar controls the amount of boost, whereas angle <code>ψ</code> controls the rotation component of the transform. But, the parameterization accepts <em>rapidity</em> as input for the boost. So we take the natural logarithm of <code>w</code> (<span>$log(w) = \phi$</span>) in order to supply the transformer with the required rapidity argument. First, we set <code>w</code> equal to one in order to preserve the scale of the Argand plane and animate the angle <code>ψ</code> through zero to 2π for rotation. The name <code>progress</code> denotes a scalar from zero to one for instantiating a different transformation at each frame of the animation.</p><pre><code class="language-julia hljs">    if status == 1 # roation
        w = 1.0
        ϕ = log(w) # rapidity
        ψ = progress * 2π
    end</code></pre><p>In the second case, we fix the rotation angle <code>ψ</code> by setting it to zero, and this time animate the rapidity by changing the value of <code>ϕ</code> at each time step.</p><pre><code class="language-julia hljs">    if status == 2 # boost
        w = max(1e-4, abs(cos(progress * 2π)))
        ϕ = log(w) # rapidity
        ψ = 0.0
    end</code></pre><p>Third, in order to get a complete picture of a four-screw we animate both rapidity <code>ϕ</code> and rotation <code>ψ</code>, at the same time.</p><pre><code class="language-julia hljs">    if status == 3 # four-screw
        w = max(1e-4, abs(cos(progress * 2π)))
        ϕ = log(w) # rapidity
        ψ = progress * 2π
    end</code></pre><p>A four-real-dimensional vector in the Minkowski vector space 𝕍 is null if and only if its Lorentz norm is equal to zero. The <em>length</em> or <em>norm</em> of an abstract vector <span>$u \in V$</span> is equivalent to the square root of the inner product of the vector with itself: <span>$&lt;u, u&gt; \equiv \sqrt{&lt;u, u&gt;} \in \R$</span>. The inner product of vectors <span>$u$</span> and <span>$v$</span> in an abstract vector space is given by <span>$u^T * g_{\mu\nu} * v$</span>, where <span>$g_{\mu\nu}$</span> denotes the metric 2-tensor. However, as an instantiation in Minkowski vector space 𝕍 with signature (+, -, -, -), the matrix <span>$g_{\mu\nu}$</span> is a diagonal of the form: <span>$g_{\mu\nu} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1 \end{bmatrix}$</span>.</p><p>Furthermore, a vector in 𝕍 is in the tangent space at some point in Einstein&#39;s spacetime, where the metric <span>$g_{\mu\nu}$</span> will not be diagonal in general. Since a Lorentz transformation of null vectors has the same effect on vectors that are not null, it makes the visualization easier to study transformations on null vectors only. On the other hand, in the Euclidean 4-space <span>$E^4$</span> the metric <span>$g_{\mu\nu}$</span> is replaced by identity matrix of dimension four. The null vectors that we use here in the Minkowski vector space have length zero in terms of the Lorentz norm, but have Euclidean norm equal to one, and so they can be regarded as elements of unit <code>Quaternion</code>. Therefore, what we are animating here is the transformation of unit quaternions that represent null vectors. </p><p>The change-of-basis transformations that we have used to instantiate <code>Whirl</code> and <code>Basemap</code> types above, can accomodate the effects of a Lorentz transformation. Then, by setting <code>ψ</code> and <code>ϕ</code> we can define a generic function <code>transform</code> to take <code>Quaternion</code> numbers as input and to give us the transformed number as output.</p><pre><code class="language-julia hljs">    transform(x::Quaternion) = begin
        T, X, Y, Z = vec(x)
        X̃ = X * cos(ψ) - Y * sin(ψ)
        Ỹ = X * sin(ψ) + Y * cos(ψ)
        Z̃ = Z * cosh(ϕ) + T * sinh(ϕ)
        T̃ = Z * sinh(ϕ) + T * cosh(ϕ)
        Quaternion(T̃, X̃, Ỹ, Z̃)
    end</code></pre><p>Every transformation in an abstract vector space such as the Minkowski vector space <code>𝕍</code> has a matrix representation. For constructing the matrix of the transform we just need to compute it four times with basis vectors. The transformation of the basis vectors of unit quaternions by <code>transform</code> are denoted by <code>r₁</code>, <code>r₂</code>, <code>r₃</code> and <code>r₄</code>. The matrix <code>_M</code> is a four by four real matrix whose rows are <code>r₁</code> through <code>r₄</code>. <code>_M</code> is the matrix representation of the transformation that is induced by <code>transform</code>.</p><pre><code class="language-julia hljs">    r₁ = transform(Quaternion(1.0, 0.0, 0.0, 0.0))
    r₂ = transform(Quaternion(0.0, 1.0, 0.0, 0.0))
    r₃ = transform(Quaternion(0.0, 0.0, 1.0, 0.0))
    r₄ = transform(Quaternion(0.0, 0.0, 0.0, 1.0))
    _M = reshape([vec(r₁); vec(r₂); vec(r₃); vec(r₄)], (4, 4))</code></pre><p>But, <code>_M</code> doesn&#39;t necessarily take unit quaternions to unit quaternions. By decomposing <code>_M</code> into eigenvalues and eigenvectors we can manipulate the transformation so that it takes unit quaternions to unit quaternions without modifying its effect on the geometrical structure of Argand plane. Despite the fact that <code>_M</code> is a matrix of real numbers, it has complex eigenvalues, as it involves a rotation. By constructing a four-complex-dimensional vector off of the eigenvalues we can normalize <code>_M</code> by normalizing the vector of eigenvalues, before reconstructing a unimodular, unitary transformation (a normal matrix). The reconstructed matrix is called <code>M</code>.</p><pre><code class="language-julia hljs">    decomposition = LinearAlgebra.eigen(_M)
    λ = LinearAlgebra.normalize(decomposition.values) # normalize eigenvalues for a unimodular transformation
    Λ = [λ[1] 0.0 0.0 0.0; 0.0 λ[2] 0.0 0.0; 0.0 0.0 λ[3] 0.0; 0.0 0.0 0.0 λ[4]]
    M = real.(decomposition.vectors * Λ * LinearAlgebra.inv(decomposition.vectors))</code></pre><p>We can assert that the transformation that is induced by <code>M</code> takes null vectors to null vectors in Minkowski vector space <code>𝕍</code>. If that is the case, then the reconstructed transformation <code>M</code> is a faithful representation and it only scales the extent of null vectors rather than null directions, compared to <code>_M</code>. A representation <code>f</code> is called a faithful representation when for different numbers <code>g</code> and <code>q</code>, <code>f(g)</code> and <code>f(q)</code> are equal if and only if <code>g = q</code>.</p><p>A spin-vector is based on the space of future or past null directions in Minkowski space-time. The field <code>ζ</code> of a <code>SpinVector</code> represents points in Argand plane. Therefore, if <code>v</code> is obtained with the transformation of <code>u</code> by <code>M</code>, then the respective spin-vectors <code>s</code> and <code>s′</code> should tell us how <code>M</code> changes Argand plane. To be precise, three different points in Argand plane, namely <code>u₁, u₂, u₃</code>, are needed to characterize the transformation. We assert that the transformation by <code>M</code> induced on Argand plane is correct, because it extends the Argand plane <code>ζ = w * exp(im * ψ) * s.ζ</code> by magnitude <code>w</code> and rotates it through angle <code>ψ</code>. So, we established the fact that normalizing the vector of eigenvalues of the transformation <code>_M</code> and reconstructing it to get <code>M</code> leaves the effect on Argand plane invariant.</p><pre><code class="language-julia hljs">    u₁ = 𝕍(1.0, 1.0, 0.0, 0.0)
    u₂ = 𝕍(1.0, 0.0, 1.0, 0.0)
    u₃ = 𝕍(1.0, 0.0, 0.0, 1.0)
    for u in [u₁, u₂, u₃]
        v = 𝕍(vec(M * Quaternion(u.a)))
        @assert(isnull(v, atol = tolerance), &quot;v ∈ 𝕍 in not null, $v.&quot;)
        s = SpinVector(u)
        s′ = SpinVector(v)
        if s.ζ == Inf # A Float64 number (the point at infinity)
            ζ = s.ζ
        else # A Complex number
            ζ = w * exp(im * ψ) * s.ζ
        end
        ζ′ = s′.ζ
        if ζ′ == Inf
            ζ = real(ζ)
        end
        @assert(isapprox(ζ, ζ′, atol = tolerance), &quot;The transformation induced on Argand plane is not correct, $ζ != $ζ′.&quot;)
    end</code></pre><p>A distinction between coordinates in Argand plane becomes relevant when we want to assert the properties of <code>M</code> on a test variable <code>ζ</code>, without applying <code>M</code> on a control variable <code>ζ′</code>. In the special case where the null direction <code>ζ</code> is the point at infinity, the north pole, we expect for the transformation induced by <code>M</code> to be inconsequential. Because <code>ζ</code> is a union of complex numbers and the singleton of infinity (of type <code>Union{Complex, ComplexF64, Float64}</code>). For an inhomogeneous coordinate system we treat the point at infinity in a different way. For example, for all values of <code>w</code>, if <code>ζ</code> equals infinity then the rotation component of a four-screw should not have any effect on the north pole. But, multiplying positive infinity by a complex number of negative magnitude makes <code>ζ</code> equal to negative infinity, which is not in Argand plane. In that case, we first check the edge case to leave <code>ζ</code> unchanged whenever its value is infinity, <code>ζ = s.ζ</code>. No amount of z-boost and rotation about the z-axis should transform the north pole. Else, <code>ζ</code> transforms as expected: <code>ζ = w * exp(im * ψ) * s.ζ</code>.</p><h2 id="Compute-a-Null-Rotation"><a class="docs-heading-anchor" href="#Compute-a-Null-Rotation">Compute a Null Rotation</a><a id="Compute-a-Null-Rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-a-Null-Rotation" title="Permalink"></a></h2><p>To understand a null rotation, imagine that you are an astronaut in empty space, far away from any celestial object. Looking at the space around you from every direction, you can see your surrounding environment through a spherical viewport. This view is called the celestial sphere of past null directions, as the light from the stars in the past reach your eyes. A null rotation translates Argand plane such that just one null direction is invariant, the point at infinity (the north pole of the celestial sphere). We control the animation of a null rotation by defining a real number <code>a</code>.</p><pre><code class="language-julia hljs">    a = sin(progress * 2π)</code></pre><p>Whenever <code>T</code> is positive, we talk about the sphere of future-pointing null directions. At this stage of the animation, the transformation <code>transform</code> defines a null rotation such that the invariant null vector is the direction <code>t + z</code>, the north pole of the sphere of future-pointing null directions, where <code>ζ</code> equals infinity. </p><pre><code class="language-julia hljs">    transform(x::Quaternion) = begin
        T, X, Y, Z = vec(x)
        X̃ = X 
        Ỹ = Y + a * (T - Z)
        Z̃ = Z + a * Y + 0.5 * a^2 * (T - Z)
        T̃ = T + a * Y + 0.5 * a^2 * (T - Z)
        Quaternion(T̃, X̃, Ỹ, Z̃)
    end

    r₁ = transform(Quaternion(1.0, 0.0, 0.0, 0.0))
    r₂ = transform(Quaternion(0.0, 1.0, 0.0, 0.0))
    r₃ = transform(Quaternion(0.0, 0.0, 1.0, 0.0))
    r₄ = transform(Quaternion(0.0, 0.0, 0.0, 1.0))
    _M = reshape([vec(r₁); vec(r₂); vec(r₃); vec(r₄)], (4, 4))
    decomposition = LinearAlgebra.eigen(_M)
    λ = decomposition.values
    Λ = [λ[1] 0.0 0.0 0.0; 0.0 λ[2] 0.0 0.0; 0.0 0.0 λ[3] 0.0; 0.0 0.0 0.0 λ[4]]
    M = real.(decomposition.vectors * Λ * LinearAlgebra.inv(decomposition.vectors))</code></pre><p>Next, we instantiate another spin-vector using <code>M * u = v</code> in order to examine the effect of the transformation <code>M</code> on Argand plane. Specifically, the point <code>ζ</code> from the Argand plane of <code>u</code> transforms into <code>α * s.ζ + β</code>, where <code>α</code> determines the extension of Argand plane and <code>β</code> the translation. The scalar <code>a</code> controls the translation of the plane because <code>β</code> is defined as <code>β = Complex(im * a)</code>. We assert that the transformation induced on Argand plane is correct by comparing the approximate equality of the Argand plane of <code>v</code> and the Argand plane of <code>u</code>. Similar to previous animation stages, the induced transformation on Argand plane by <code>M</code> is completely characterized using three different points: <code>u₁, u₂, u₃</code>. After transforming <code>u</code> by <code>M</code> we assert that the result <code>v</code> is still a null vector.</p><pre><code class="language-julia hljs">    u₁ = 𝕍(1.0, 1.0, 0.0, 0.0)
    u₂ = 𝕍(1.0, 0.0, 1.0, 0.0)
    u₃ = 𝕍(1.0, 0.0, 0.0, 1.0)
    for u in [u₁, u₂, u₃]
        v = 𝕍(vec(M * Quaternion(u.a)))
        @assert(isnull(v, atol = tolerance), &quot;v ∈ 𝕍 in not a null vector, $v.&quot;)
        s = SpinVector(u) # TODO: visualize the spin-vectors as frames on S⁺
        s′ = SpinVector(v)
        β = Complex(im * a)
        α = 1.0
        ζ = α * s.ζ + β
        ζ′ = s′.ζ
        if ζ′ == Inf
            ζ = real(ζ)
        end
        @assert(isapprox(ζ, ζ′, atol = tolerance), &quot;The transformation induced on Argand plane is not correct, $ζ != $ζ′.&quot;)
    end</code></pre><p>Finally, we also assert that the null direction <code>z + t</code> is invariant under the transformation <code>M</code> because it is a null rotation with a fixed null direction at the north pole. The animation of a null rotation is correct if all of the assertions evaluate true.</p><pre><code class="language-julia hljs">    v₁ = 𝕍(normalize(ℝ⁴(1.0, 0.0, 0.0, 1.0)))
    v₂ = 𝕍(vec(M * Quaternion(vec(v₁))))
    @assert(isnull(v₁, atol = tolerance), &quot;vector t + z in not null, $v₁.&quot;)
    @assert(isapprox(v₁, v₂, atol = tolerance), &quot;The null vector t + z is not invariant under the null rotation, $v₁ != $v₂.&quot;)</code></pre><h2 id="Update-the-Camera"><a class="docs-heading-anchor" href="#Update-the-Camera">Update the Camera</a><a id="Update-the-Camera-1"></a><a class="docs-heading-anchor-permalink" href="#Update-the-Camera" title="Permalink"></a></h2><p>The 3D camera of the scene requires the <strong>eye position</strong>, <strong>look at</strong>, and <strong>up</strong> vectors for positioning and orientation. The function <code>update_cam!</code> takes the scene object along with the three required vectors as arguments and updates the camera. But, our camera position and orientation vectors are of type ℝ³, and not <code>Vec3f</code>. To match the argument type we need to use the generic function <code>vec</code> and the <code>splat</code> operator in order to instantiate objects of type <code>Vec3f</code>, because <code>update_cam!</code> is going to match the given type with its own signature.</p><pre><code class="language-julia hljs">    GLMakie.update_cam!(lscene.scene, GLMakie.Vec3f(vec(eyeposition)...), GLMakie.Vec3f(vec(lookat)...), GLMakie.Vec3f(vec(up)...))</code></pre><h2 id="Record-an-Animation"><a class="docs-heading-anchor" href="#Record-an-Animation">Record an Animation</a><a id="Record-an-Animation-1"></a><a class="docs-heading-anchor-permalink" href="#Record-an-Animation" title="Permalink"></a></h2><p>Updating the base maps requires a base point in the section denoted by <code>q</code> and the transformation <code>M</code>. Then, we use <code>M</code> to update base maps 1, 2, 3 and 4. For we want to have different choices of an inertial reference frame in the tangent space of some point in spacetime. The generic function <code>update!</code> updates base maps by changing the structurally embedded observables, and then the graphical shapes take different forms accordingly.</p><p>Although we are talking about points in the bundle, embedded in <code>ℝ⁴</code> and of type <code>Quaternion</code>, the generic function <code>project</code> converts them to points in <code>ℝ³</code>. The one method of <code>project</code> takes the given point <code>q</code> ∈ S³ ⊂ ℂ² and turns it into a point in the Euclidean space E³ ⊂ ℝ³ using stereographic projection. We identify <span>$\mathbb{R}^4 \to \mathbb{C}^2$</span> given by <span>$(x_1, x_2, x_3, x_4) \mapsto (x_1 + i x_2, x_3 + i x_4)$</span>. Then, the stereographic projection is given by: <span>$project: S^3 \setminus {(1, 0)} \to \mathbb{R}^3$</span> given by <span>$(x_1, x_2, x_3, x_4) \mapsto \frac{[x_2, x_3, x_4]^T}{1 - x_1}$</span>.</p><p>Whenever we call the <code>update!</code> function with an object like <code>basemap1</code>, giving transformation <code>M</code>, two things happn under the hood for deforming the graphics (<code>update!(basemap1, q, gauge1, M)</code>). First, a matrix of type ℝ³ is made, <code>Matrix{ℝ³}</code>. That is the job of one of the methods of the generic function <code>make</code>. The correct dispatch is selected automatically for the job, based on the argument signature (whether the first argument is of type <code>Whirl</code> or <code>Basemap</code> for example). The selected method makes a 2-surface (lattice) of the horizontal section at base point <code>q</code> after transforming by <code>M</code>, with the given <code>segments</code> number, <code>gauge</code> and <code>chart</code>. A chart and a gauge play the role of a choice of local trivialization of the Hopf bundle, as an atlas, for the purpose of constructing a pullback of the Earth&#39;s surface.</p><p>Second, the matrix of <code>ℝ³</code> along with the given basemap&#39;s observables are passed to the function <code>updatesurface!</code> for updating the observables. For each coordinate component x, y and z in the Euclidean 3-space <span>$E^3$</span>, there is a corresponding matrix of real numbers, of the same size: (<code>segments</code> by <code>segments</code>). In the type structure of a <code>Basemap</code> or a <code>Whirl</code> there is a tuple whose elements are of type <code>Observable</code>. Each element of the three-tuple in turn contains a matrix of components x, y or z. Reshaping a matrix of 3-vectors into three matrices of scalars is done because when we implicitly instantiated a <code>GLMakie</code> surface in the beginning, we supplied it with three observables representing x, y and z coordinates separately. The generic function <code>buildsurface</code> from the source file <em>surface.jl</em> builds a surface with the given <code>scene</code>, <code>value</code>, <code>color</code> and <code>transparency</code>. Here, the <code>value</code> argument is of type <code>Matrix{ℝ³}</code>. The interface between the construction of our base maps (or whirls) and the graphics engine is essentially a reshaping and type conversion. See <em>surface_tests.jl</em> for use cases.</p><p>Every time we update the observables of a <code>Whirl</code> under transformation by <code>M</code>, we need to access the coordinates of the boundary data (<code>update!(whirls1[i], points[i], gauge1, gauge2, M)</code>). But the coordinates are not changed, and instead the change-of-basis is taken care of by the map <code>M</code>. The coordinate component <code>ϕ</code> is divided by a factor of four since in geographic coordinates longitudes range from -π to +π, whereas latitudes range from -π / 2 to +π / 2 (<code>exp(ϕ / 4 * K(1) + θ / 2 * K(2)))</code>). This division rescales the longitude component of coordinates and allows us to have a square bundle chart, compared to coordinate components <code>θ</code>. Rescaling <code>θ</code> and <code>ϕ</code> aligns the boundaries of horizontal and vertical subspaces. We finish the animation of one time-step after updating the last <code>Whirl</code>.</p><p>The function <code>animate</code> takes as input an integer called <code>frame</code> and updates the scene observables according to the stages that we described earlier. First, it calculates the progress of the animation frames, dividing <code>frame</code> by <code>frames_number</code>. For different properties of Lorentz transformations we have four stages, each stage having its own progress. The signature of the four-screw animator function is <code>compute_fourscrew(progress::Float64, status::Int)</code>. For example, stage one animates a proper rotation of Argand plane by calling the function <code>compute_fourscrew</code> with <code>status</code> equal to 1. Stage 2 animates a pure z-boost. Then, stage 3 animates a four-screw. Finally, stage 4 animates a null rotation by calling the function <code>compute_nullrotation</code>. After calling each stage function, we update the camera by calling the function <code>updatecamera</code>.</p><pre><code class="language-julia hljs">    animate(frame::Int) = begin
        progress = frame / frames_number
        stage = min(totalstages - 1, Int(floor(totalstages * progress))) + 1
        stageprogress = totalstages * (progress - (stage - 1) * 1.0 / totalstages)
        println(&quot;Frame: $frame, Stage: $stage, Total Stages: $totalstages, Progress: $stageprogress&quot;)
        if stage == 1
            M = compute_fourscrew(stageprogress, 1)
        elseif stage == 2
            M = compute_fourscrew(stageprogress, 2)
        elseif stage == 3
            M = compute_fourscrew(stageprogress, 3)
        elseif stage == 4
            M = compute_nullrotation(stageprogress)
        end
        update!(basemap1, q, gauge1, M)
        update!(basemap2, q, gauge2, M)
        update!(basemap3, q, gauge3, M)
        update!(basemap4, q, gauge4, M)
        for i in eachindex(whirls1)
            update!(whirls1[i], points[i], gauge1, gauge2, M)
            update!(whirls2[i], points[i], gauge2, gauge3, M)
            update!(whirls3[i], points[i], gauge3, gauge4, M)
            update!(whirls4[i], points[i], gauge4, gauge5, M)
        end
        updatecamera()
    end</code></pre><p>To create an animation you need to use the <code>record</code> function. In summary, we instantiated a <code>Scene</code> inside a <code>Figure</code>. Next, we created and animated observables in the scene, on a frame by frame basis. Now, we record the scene by passing the figure <code>fig</code>, the file path of the resulting video, and the range of frame numbers to the <code>record</code> function. The frame is incremented by <code>record</code> and the frame number is passed to the function <code>write</code> to animate the observables. Once the frame number reaches the total number of animation frames, recording is finished and a video file is saved on the hard drive at the file path: <em>gallery/planethopf.mp4</em>.</p><pre><code class="language-julia hljs">    GLMakie.record(fig, joinpath(&quot;gallery&quot;, &quot;$modelname.mp4&quot;), 1:frames_number) do frame
        animate(frame)
    end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="newsreport.html">News Report »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.3 on <span class="colophon-date" title="Thursday 15 May 2025 16:12">Thursday 15 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
